"""
Converts CNS/HADDOCK .tbl file into ATTRACT restraint file
Author: Sjoerd de Vries, TU Munich

Syntax: tbl2attract <.tbl file> {[--pdb <PDB file>]} {[--mapping <mapping files>] [options]
 
 PDBs must be reduced, and for every PDB file, a mapping file must be supplied
 The first PDB will be "segid A" in the .tbl file, the second PDB "segid B", etc.
"""

import sys

import argparse
parser = argparse.ArgumentParser(description=__doc__,
                          formatter_class=argparse.RawDescriptionHelpFormatter)
parser.add_argument("tblfile",help="CNS/HADDOCK .tbl file to convert")
parser.add_argument("--pdbs",dest="pdbs", nargs="+",
                    help="Provide resid mapping file generated by reduce",default=[])
parser.add_argument("--mappings",dest="mappings", nargs="+",
                    help="Provide resid mapping file generated by reduce", default=[])
parser.add_argument("--k", type=float, default=1.0,
                    help="Force constant for distance restraints")
parser.add_argument("--mode", type = str, choices = ["harmonic", "haddock", "position","step","bump"], default = "harmonic",
                    help="""Specifies how the restraints in the .tbl are interpreted. The following modes are possible
                    harmonic: Defines harmonic distance restraints between two atomic selections. Format: <selection 1> <selection 2> <distance> <dminus> <dplus>
                    haddock: Same as harmonic, but enables soft-square potential and restraint cross-validation
                    step: Same as harmonic, but defines a step potential between distance-dminus and distance+dplus
                    bump: Same as harmonic, but defines double quadratic potential between r1, r2, r3, r4
                    position: Defines an harmonic distance restraint for each atom in a selection to a reference point in space. 
                      Format: <selection> <distance> <dminus> <dplus> <type> <x> <y> <z>                   
                      <type> can be: x, y, z, xy, xz, yz or xyz
                       The type determines which coordinate(s) of the atom are used to compute <distance>
                        e.g. "x" defines a planar region, "xy" a cylindrical region and "xyz" a spherical region                       
                      <x> <y> <z>: defines the reference point
                    """)
parser.add_argument("--softsquare", type=float, default=2.0,
                    help="HADDOCK-mode softsquare limit, indicating the maximum distance violation after which the restraint potential becomes linear")
parser.add_argument("--chance_removal", type=float, default=0.5,
                    help="chance of removal for HADDOCK-mode restraints; equal to 1/noecv, where noecv is the HADDOCK cross-validation parameter")

args = parser.parse_args()
assert len(args.pdbs) == len(args.mappings), (len(args.pdbs), len(args.mappings))
tbldata = open(args.tblfile).read().lower()

try:
  import lark
except ImportError:
  raise ImportError("Parsing CNS .tbl files requires the Lark (lark-parser) library")  


from lark import Lark
import os
currdir = os.path.dirname(__file__) 
parser = Lark(
  open(os.path.abspath(currdir) + "/tbl_grammar.ebnf").read(), 
  parser="earley", start="assign_statements"
)

from rmsdlib import read_pdb

pdbs = []
for p in args.pdbs:
  pdbs.append(read_pdb(p))
  

resmaps = []
for m in args.mappings:
  resmap = {}
  for l in open(m):
    ll = l.split()
    if not len(ll) == 2: continue
    resmap[ll[0]] = int(ll[1])
  resmaps.append(resmap)

import numpy
pdblen = [len(list(p.atoms())) for p in pdbs]
pdbcumlen = [0]
for plen in pdblen:
  pdbcumlen.append(plen + pdbcumlen[-1])  
mask0 = numpy.zeros(pdbcumlen[-1], dtype="bool")
mask1 = numpy.ones(pdbcumlen[-1], dtype="bool")

def select_segid(token):
  segid = token.value
  #print("SEGID", segid)
  m = mask0.copy()
  segid = segid.strip()
  assert len(segid) == 1 #TODO: support for body >26
  body = ord(segid) - ord('a') + 1
  assert body <= len(pdbs), (body, len(pdbs))
  m[pdbcumlen[body-1]:pdbcumlen[body]] = 1
  return m
   
def select_resid(token):
  resid = token.value
  #print("RESID", resid)
  m = mask0.copy()
  count = 0
  resid = resid.strip()
  for pnr, p in enumerate(pdbs):
    resmap = resmaps[pnr]
    resnr = None
    if resid in resmap: 
      resnr = resmap[resid]
    for a in p.atoms():
      if a.resnr == resnr: 
        m[count] = 1
      count += 1 
  return m

def select_resname(token):
  resname = token.value
  #print("RESNAME", resname)
  m = mask0.copy()
  count = 0
  resname = resname.strip()
  for p in pdbs:
    for a in p.atoms():
      if a.resname == resname:
        m[count] = 1
      count += 1 
  return m

def select_name(token):
  name = token.value
  #print("NAME", name)
  m = mask0.copy()
  count = 0
  name = name.strip().upper()
  for p in pdbs:
    for a in p.atoms():
      if a.name == name:
        m[count] = 1
      count += 1 
  return m

def evaluate_factor(node):
  assert node.data == "factor", node.data
  assert len(node.children) == 1, node
  subnode = node.children[0]
  assert len(subnode.children) > 0, node
  child = subnode.children[0]
  type = subnode.data
  if type == "not":
    mask = evaluate_atom_selection(child)
    result = ~mask
  elif type == "segid":
    result = select_segid(child)
  elif type == "resid":
    result = select_resid(child)
  elif type == "resname":
    result = select_resname(child)
  elif type == "name":
    result = select_name(child)
  else:
    raise Exception("Selection operator {} is not supported".format(type))
  #print("FACTOR", type, result.sum())
  return result

def evaluate_term(node):
  assert node.data == "term", node.data
  mask = mask1.copy()
  for child in node.children:
    type = child.data
    if type == "atom_selection":
      childmask = evaluate_atom_selection(child)
    elif type == "factor":
      childmask = evaluate_factor(child)
    else:
      raise TypeError(type)
    mask &= childmask
  return mask

def evaluate_atom_selection(node):
  assert node.data == "atom_selection", node.data
  mask = mask0.copy()
  for child in node.children:
    assert child.data == "term", child.data
    childmask = evaluate_term(child)
    mask |= childmask
  return mask


def evaluate_top_atom_selection(node):
  mask = evaluate_atom_selection(node)
  maskhash = hash(buffer(mask))
  #print "TERM", sum(mask)
  try:
    maskindex = maskhashes.index(maskhash)
  except ValueError:
    maskhashes.append(maskhash)
    masks.append(mask)
    maskindex = len(masks) - 1
  return maskindex

#Restraint data
class Restraint(object):
  def __init__(self):
    self.maskindices = []

restraints = []
masks = []
maskhashes = []

tree = parser.parse(tbldata)
assert tree.data == "assign_statements"
#print(tree.pretty()); sys.exit()

form = "assign_statement_2"
if args.mode == "position":
  form = "assign_statement_positional"
for node in tree.children:
  if node.data != form:
    raise Exception("Restraints of the form '{}' are not supported".format(node.data))
  if form == "assign_statement_2":
    sele1, sele2, distance, dminus, dplus = node.children
  elif form == "assign_statement_positional":
    sele, distance, dminus, dplus, xyz, vector = node.children
  else:
    raise Exception
  
  rest = Restraint()
  rest.distance = float(distance.value)
  rest.dminus = float(dminus.value)
  rest.dplus = float(dplus.value)
  
  if args.mode == "position":
    rest.typ = float(xyz.data)
    rest.vector = parse_vector(vector)
    maskindex = evaluate_top_atom_selection(sele)
    rest.maskindices.append(maskindex)
  else: #"harmonic", "haddock", "bump", "step"
    maskindex1 = evaluate_top_atom_selection(sele1)
    rest.maskindices.append(maskindex1)
    maskindex2 = evaluate_top_atom_selection(sele2)
    rest.maskindices.append(maskindex2)      
  restraints.append(rest)

for mnr, m in enumerate(masks):
  if not sum(m):
    raise ValueError("No atoms found for restraint %d" %mnr)
  
  print "selection%d" % (mnr+1),  
  print sum(m),
  for mm in numpy.where(m>0)[0]: print mm+1,
  print
print
for rest in restraints:
  mindist = rest.distance - rest.dminus
  maxdist = rest.distance + rest.dplus
  if args.mode == "position":
    x, y, z = rest.vector.x, rest.vector.y, rest.vector.z
    r = "selection%d 7 %s %s %s %s %s %s %s" % (rest.maskindices[0]+1, mindist, maxdist, args.k, rest.typ, x, y, z)
    print r
  else: # "harmonic", "haddock", "step", "bump"
    r = "selection%d selection%d" % (rest.maskindices[0]+1, rest.maskindices[1]+1)  
    if args.mode == "haddock": 
      if mindist > 0:
        raise Exception("HADDOCK restraints with minimum distance > 0 are not supported")
      print r + " 2 %s %s %s %s" % (maxdist, args.k, args.softsquare, args.chance_removal)
    elif args.mode== "step":
      if mindist < 0 or maxdist < 0:
        raise Exception("Step potential restraints with limits < 0 are not supported")
      print r + " 6 %s %s %s" % (maxdist, args.k, mindist)
    elif args.mode=="bump":
      if mindist < 0 or maxdist < 0:
        raise Exception("Bump potential restraints with limits < 0 are not supported")
      print r + " 8 %s %s %s %s" % (mindist, rest.distance, rest.dplus, args.k)
    else: #harmonic
      if mindist == maxdist:
        print r + " 4 %s %s" % (maxdist, args.k)
      else:
        print r + " 1 %s %s" % (maxdist, args.k)
        if mindist > 0:
          print r + " 3 %s %s" % (mindist, args.k)
      
  
