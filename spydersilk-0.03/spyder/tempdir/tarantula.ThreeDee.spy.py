
class ThreeDee(Object):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'ThreeDee.spy'


  Base class for three-dimensional objects
  
----------------------------------------------------------------------
Spyder definition:

Type ThreeDee {
  #!#!#!
  Base class for three-dimensional objects
  #!#!#!
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "ThreeDee"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a ThreeDee object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a ThreeDee object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    ThreeDee.__dict__[ThreeDee.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""
    self.validate()

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(ThreeDee, method, self)
    return m
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,ThreeDee) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["ThreeDee"] = ThreeDee
spyder.core.error["ThreeDee"] = {}
if hasattr(ThreeDee, '_register_errors'): ThreeDee._register_errors()
ThreeDee._requiredmembers = []
ThreeDee._defaultmembers = []
ThreeDee.__form__()
ResourceThreeDee = spyder.__types__["_Resource"](ThreeDee)

ThreeDee.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  ThreeDee,
  "constructor_fromany",
)
ThreeDee.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  ThreeDee,
  "constructor_fromany",
)
ThreeDee.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  ThreeDee,
  "constructor_fromany",
)

class ThreeDeeArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "ThreeDeeArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, ThreeDeeArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(ThreeDeeArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (ThreeDeeArray, target, self,deepcopy),
     name="ThreeDeeArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(ThreeDeeArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != ThreeDee: self[vnr] = ThreeDee(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((ThreeDeeArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((ThreeDeeArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(ThreeDee,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a ThreeDeeArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    ThreeDeeArray.__dict__[ThreeDeeArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.ThreeDee, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a ThreeDeeArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("ThreeDeeArray","ThreeDee","SPLIT")
spyder.core.defineconverter("ThreeDee","ThreeDeeArray","CAST")
spyder.__types__["ThreeDeeArray"] = globals()["ThreeDeeArray"]  
arrayclass = spyder.__types__["ThreeDeeArray"]
spyder.__types__["ResourceThreeDeeArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class ThreeDeeArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "ThreeDeeArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, ThreeDeeArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(ThreeDeeArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (ThreeDeeArrayArray, target, self,deepcopy),
     name="ThreeDeeArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(ThreeDeeArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != ThreeDee: self[vnr] = ThreeDee(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((ThreeDeeArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((ThreeDeeArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(ThreeDeeArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a ThreeDeeArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    ThreeDeeArrayArray.__dict__[ThreeDeeArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.ThreeDeeArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a ThreeDeeArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("ThreeDeeArrayArray","ThreeDeeArray","SPLIT")
spyder.core.defineconverter("ThreeDeeArray","ThreeDeeArrayArray","CAST")
spyder.__types__["ThreeDeeArrayArray"] = globals()["ThreeDeeArrayArray"]  
arrayclass = spyder.__types__["ThreeDeeArrayArray"]
spyder.__types__["ResourceThreeDeeArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()

