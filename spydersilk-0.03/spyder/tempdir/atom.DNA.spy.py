
class DNABasePuckerGroup(Object):
  """Spyder-generated class

 module spyder.modules.atom
 file 'DNA.spy'


  TODO documentation
  
----------------------------------------------------------------------
Spyder definition:

Type DNABasePuckerGroup {
  #!#!#!
  TODO documentation
  #!#!#!
  Enum nform("a-form", "b-form", "other") = "b-form"
  Range range
  *AngleErr nu2
  *AngleErr nu3
  *AngleErr nu4
  validate {
    assert (nu2 != None) == (nu3 != None)
    assert (nu2 != None) == (nu4 != None)
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "DNABasePuckerGroup"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNABasePuckerGroup object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNABasePuckerGroup object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    DNABasePuckerGroup.__dict__[DNABasePuckerGroup.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a DNABasePuckerGroup object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (DNABasePuckerGroup) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (DNABasePuckerGroup) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (DNABasePuckerGroup) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (DNABasePuckerGroup) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("DNABasePuckerGroup") and args[0][len("DNABasePuckerGroup"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (DNABasePuckerGroup) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (DNABasePuckerGroup) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (DNABasePuckerGroup) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, range,nform,nu2,nu3,nu4):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.range = reconstruct(self, Range,"range",range)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if nform is default0 or (nform.__class__ is default0.__class__ and nform == default0):      reconstruct_func = reconstruct_default
    try:
      self.nform = reconstruct_func(self, String,"nform",nform)
    except Exception as exc:
      exc.__context__ = None; raise
    self.nu2 = None
    try:
      if nu2 is not None: self.nu2 = reconstruct(self, AngleErr,"nu2",nu2)
    except Exception as exc:
      exc.__context__ = None; raise
    self.nu3 = None
    try:
      if nu3 is not None: self.nu3 = reconstruct(self, AngleErr,"nu3",nu3)
    except Exception as exc:
      exc.__context__ = None; raise
    self.nu4 = None
    try:
      if nu4 is not None: self.nu4 = reconstruct(self, AngleErr,"nu4",nu4)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("range",)
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,range,nform="b-form",nu2=None,nu3=None,nu4=None,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return range,nform,nu2,nu3,nu4
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      range = _a.range
    except AttributeError:
      _missing_members.append('range')
    nform = "b-form"
    if hasattr(_a,"nform") and _a.nform != None: nform = _a.nform
    nu2 = None
    if hasattr(_a,"nu2") and _a.nu2 != None: nu2 = _a.nu2
    nu3 = None
    if hasattr(_a,"nu3") and _a.nu3 != None: nu3 = _a.nu3
    nu4 = None
    if hasattr(_a,"nu4") and _a.nu4 != None: nu4 = _a.nu4
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (range,nform,nu2,nu3,nu4,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      range = _a['range']
    except KeyError:
      _missing_members.append('range')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    nform = "b-form"
    if "nform" in _a: nform = _a["nform"]
    if isinstance(_a, dict) and "nform" in _a: nform = _a["nform"]
    nu2 = None
    if "nu2" in _a: nu2 = _a["nu2"]
    if isinstance(_a, dict) and "nu2" in _a: nu2 = _a["nu2"]
    nu3 = None
    if "nu3" in _a: nu3 = _a["nu3"]
    if isinstance(_a, dict) and "nu3" in _a: nu3 = _a["nu3"]
    nu4 = None
    if "nu4" in _a: nu4 = _a["nu4"]
    if isinstance(_a, dict) and "nu4" in _a: nu4 = _a["nu4"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (range,nform,nu2,nu3,nu4,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.range = Range(self.range)
      self.nform = String(self.nform)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    range = self.range
    nform = self.nform
    nu2 = self.nu2
    nu3 = self.nu3
    nu4 = self.nu4
    if nform is not None: spyder.core._assert(self, 'nform in ("a-form", "b-form", "other")', 'if nform is not None: assert nform in ("a-form", "b-form", "other")')
    spyder.core._assert(self, '(nu2 != None) == (nu3 != None)', 'assert (nu2 != None) == (nu3 != None)')
    spyder.core._assert(self, '(nu2 != None) == (nu4 != None)', 'assert (nu2 != None) == (nu4 != None)')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'if nform is not None: assert nform in ("a-form", "b-form", "other")', None)
    spyder.core._register_error(cls, 'assert (nu2 != None) == (nu3 != None)', None)
    spyder.core._register_error(cls, 'assert (nu2 != None) == (nu4 != None)', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.nform
    if type(v) != String: v = String(v)
    ret += "%snform = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.range
    if type(v) != Range: v = Range(v)
    ret += "%srange = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.nu2
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      ret += "%snu2 = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.nu3
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      ret += "%snu3 = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.nu4
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      ret += "%snu4 = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.nform
    if type(v) != String: v = String(v)
    _d["nform"] = v.dict()
    v = self.range
    if type(v) != Range: v = Range(v)
    _d["range"] = v.dict()
    v = self.nu2
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      _d["nu2"] = v.dict()
    v = self.nu3
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      _d["nu3"] = v.dict()
    v = self.nu4
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      _d["nu4"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(DNABasePuckerGroup, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(DNABasePuckerGroup, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DNABasePuckerGroup, target, self, deepcopy),
     name="DNABasePuckerGroup=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,DNABasePuckerGroup) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.range != _a.range: return False
    if self.nform != _a.nform: return False
    if self.nu2 != _a.nu2: return False
    if self.nu3 != _a.nu3: return False
    if self.nu4 != _a.nu4: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    range = self.range
    nform = self.nform
    nu2 = self.nu2
    nu3 = self.nu3
    nu4 = self.nu4
    nform.options = "a-form", "b-form", "other"
if issubclass(Range,Spyder.String) or issubclass(Range,Spyder.Data):
  if not issubclass(DNABasePuckerGroup,getattr(Spyder,"Degenerate")):
    raise TypeError("Spyder type 'DNABasePuckerGroup' is degenerate: it has no more than one required member, and the first member can be constructed from a string.\nPlease change the members, or inherit explicitly from Spyder.Degenerate")
spyder.__types__["DNABasePuckerGroup"] = DNABasePuckerGroup
spyder.core.error["DNABasePuckerGroup"] = {}
if hasattr(DNABasePuckerGroup, '_register_errors'): DNABasePuckerGroup._register_errors()
DNABasePuckerGroup._requiredmembers = [['Range', 'range', 2]]
DNABasePuckerGroup._defaultmembers = [['String', 'nform', '"b-form"', 1], ['AngleErr', 'nu2', 'None', 3], ['AngleErr', 'nu3', 'None', 4], ['AngleErr', 'nu4', 'None', 5]]
DNABasePuckerGroup.__form__()
ResourceDNABasePuckerGroup = spyder.__types__["_Resource"](DNABasePuckerGroup)

DNABasePuckerGroup.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  DNABasePuckerGroup,
  "constructor_fromany",
)
DNABasePuckerGroup.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  DNABasePuckerGroup,
  "constructor_fromany",
)
DNABasePuckerGroup.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  DNABasePuckerGroup,
  "constructor_fromany",
)

class DNABasePuckerGroupArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "DNABasePuckerGroupArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, DNABasePuckerGroupArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(DNABasePuckerGroupArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DNABasePuckerGroupArray, target, self,deepcopy),
     name="DNABasePuckerGroupArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(DNABasePuckerGroupArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != DNABasePuckerGroup: self[vnr] = DNABasePuckerGroup(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((DNABasePuckerGroupArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((DNABasePuckerGroupArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(DNABasePuckerGroup,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a DNABasePuckerGroupArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    DNABasePuckerGroupArray.__dict__[DNABasePuckerGroupArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.DNABasePuckerGroup, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNABasePuckerGroupArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("DNABasePuckerGroupArray","DNABasePuckerGroup","SPLIT")
spyder.core.defineconverter("DNABasePuckerGroup","DNABasePuckerGroupArray","CAST")
spyder.__types__["DNABasePuckerGroupArray"] = globals()["DNABasePuckerGroupArray"]  
arrayclass = spyder.__types__["DNABasePuckerGroupArray"]
spyder.__types__["ResourceDNABasePuckerGroupArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class DNABasePuckerGroupArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "DNABasePuckerGroupArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, DNABasePuckerGroupArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(DNABasePuckerGroupArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DNABasePuckerGroupArrayArray, target, self,deepcopy),
     name="DNABasePuckerGroupArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(DNABasePuckerGroupArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != DNABasePuckerGroup: self[vnr] = DNABasePuckerGroup(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((DNABasePuckerGroupArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((DNABasePuckerGroupArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(DNABasePuckerGroupArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a DNABasePuckerGroupArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    DNABasePuckerGroupArrayArray.__dict__[DNABasePuckerGroupArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.DNABasePuckerGroupArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNABasePuckerGroupArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("DNABasePuckerGroupArrayArray","DNABasePuckerGroupArray","SPLIT")
spyder.core.defineconverter("DNABasePuckerGroupArray","DNABasePuckerGroupArrayArray","CAST")
spyder.__types__["DNABasePuckerGroupArrayArray"] = globals()["DNABasePuckerGroupArrayArray"]  
arrayclass = spyder.__types__["DNABasePuckerGroupArrayArray"]
spyder.__types__["ResourceDNABasePuckerGroupArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class DNABaseDihedralGroup(Object):
  """Spyder-generated class

 module spyder.modules.atom
 file 'DNA.spy'


  TODO documentation
  
----------------------------------------------------------------------
Spyder definition:

Type DNABaseDihedralGroup {
  #!#!#!
  TODO documentation
  #!#!#!
  Enum nform("a-form", "b-form", "other") = "b-form"
  Range range
  *AngleErr alpha
  *AngleErr beta
  *AngleErr gamma
  *AngleErr delta
  *AngleErr epsilon
  *AngleErr zeta
  validate {
    assert (alpha != None) == (beta != None)
    assert (alpha != None) == (gamma != None)
    assert (alpha != None) == (delta != None)
    assert (alpha != None) == (epsilon != None)
    assert (alpha != None) == (zeta != None)
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "DNABaseDihedralGroup"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNABaseDihedralGroup object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNABaseDihedralGroup object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    DNABaseDihedralGroup.__dict__[DNABaseDihedralGroup.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a DNABaseDihedralGroup object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (DNABaseDihedralGroup) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (DNABaseDihedralGroup) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (DNABaseDihedralGroup) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (DNABaseDihedralGroup) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("DNABaseDihedralGroup") and args[0][len("DNABaseDihedralGroup"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (DNABaseDihedralGroup) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (DNABaseDihedralGroup) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (DNABaseDihedralGroup) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, range,nform,alpha,beta,gamma,delta,epsilon,zeta):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.range = reconstruct(self, Range,"range",range)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if nform is default0 or (nform.__class__ is default0.__class__ and nform == default0):      reconstruct_func = reconstruct_default
    try:
      self.nform = reconstruct_func(self, String,"nform",nform)
    except Exception as exc:
      exc.__context__ = None; raise
    self.alpha = None
    try:
      if alpha is not None: self.alpha = reconstruct(self, AngleErr,"alpha",alpha)
    except Exception as exc:
      exc.__context__ = None; raise
    self.beta = None
    try:
      if beta is not None: self.beta = reconstruct(self, AngleErr,"beta",beta)
    except Exception as exc:
      exc.__context__ = None; raise
    self.gamma = None
    try:
      if gamma is not None: self.gamma = reconstruct(self, AngleErr,"gamma",gamma)
    except Exception as exc:
      exc.__context__ = None; raise
    self.delta = None
    try:
      if delta is not None: self.delta = reconstruct(self, AngleErr,"delta",delta)
    except Exception as exc:
      exc.__context__ = None; raise
    self.epsilon = None
    try:
      if epsilon is not None: self.epsilon = reconstruct(self, AngleErr,"epsilon",epsilon)
    except Exception as exc:
      exc.__context__ = None; raise
    self.zeta = None
    try:
      if zeta is not None: self.zeta = reconstruct(self, AngleErr,"zeta",zeta)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("range",)
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,range,nform="b-form",alpha=None,beta=None,gamma=None,delta=None,epsilon=None,zeta=None,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return range,nform,alpha,beta,gamma,delta,epsilon,zeta
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      range = _a.range
    except AttributeError:
      _missing_members.append('range')
    nform = "b-form"
    if hasattr(_a,"nform") and _a.nform != None: nform = _a.nform
    alpha = None
    if hasattr(_a,"alpha") and _a.alpha != None: alpha = _a.alpha
    beta = None
    if hasattr(_a,"beta") and _a.beta != None: beta = _a.beta
    gamma = None
    if hasattr(_a,"gamma") and _a.gamma != None: gamma = _a.gamma
    delta = None
    if hasattr(_a,"delta") and _a.delta != None: delta = _a.delta
    epsilon = None
    if hasattr(_a,"epsilon") and _a.epsilon != None: epsilon = _a.epsilon
    zeta = None
    if hasattr(_a,"zeta") and _a.zeta != None: zeta = _a.zeta
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (range,nform,alpha,beta,gamma,delta,epsilon,zeta,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      range = _a['range']
    except KeyError:
      _missing_members.append('range')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    nform = "b-form"
    if "nform" in _a: nform = _a["nform"]
    if isinstance(_a, dict) and "nform" in _a: nform = _a["nform"]
    alpha = None
    if "alpha" in _a: alpha = _a["alpha"]
    if isinstance(_a, dict) and "alpha" in _a: alpha = _a["alpha"]
    beta = None
    if "beta" in _a: beta = _a["beta"]
    if isinstance(_a, dict) and "beta" in _a: beta = _a["beta"]
    gamma = None
    if "gamma" in _a: gamma = _a["gamma"]
    if isinstance(_a, dict) and "gamma" in _a: gamma = _a["gamma"]
    delta = None
    if "delta" in _a: delta = _a["delta"]
    if isinstance(_a, dict) and "delta" in _a: delta = _a["delta"]
    epsilon = None
    if "epsilon" in _a: epsilon = _a["epsilon"]
    if isinstance(_a, dict) and "epsilon" in _a: epsilon = _a["epsilon"]
    zeta = None
    if "zeta" in _a: zeta = _a["zeta"]
    if isinstance(_a, dict) and "zeta" in _a: zeta = _a["zeta"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (range,nform,alpha,beta,gamma,delta,epsilon,zeta,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.range = Range(self.range)
      self.nform = String(self.nform)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    range = self.range
    nform = self.nform
    alpha = self.alpha
    beta = self.beta
    gamma = self.gamma
    delta = self.delta
    epsilon = self.epsilon
    zeta = self.zeta
    if nform is not None: spyder.core._assert(self, 'nform in ("a-form", "b-form", "other")', 'if nform is not None: assert nform in ("a-form", "b-form", "other")')
    spyder.core._assert(self, '(alpha != None) == (beta != None)', 'assert (alpha != None) == (beta != None)')
    spyder.core._assert(self, '(alpha != None) == (gamma != None)', 'assert (alpha != None) == (gamma != None)')
    spyder.core._assert(self, '(alpha != None) == (delta != None)', 'assert (alpha != None) == (delta != None)')
    spyder.core._assert(self, '(alpha != None) == (epsilon != None)', 'assert (alpha != None) == (epsilon != None)')
    spyder.core._assert(self, '(alpha != None) == (zeta != None)', 'assert (alpha != None) == (zeta != None)')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'if nform is not None: assert nform in ("a-form", "b-form", "other")', None)
    spyder.core._register_error(cls, 'assert (alpha != None) == (beta != None)', None)
    spyder.core._register_error(cls, 'assert (alpha != None) == (gamma != None)', None)
    spyder.core._register_error(cls, 'assert (alpha != None) == (delta != None)', None)
    spyder.core._register_error(cls, 'assert (alpha != None) == (epsilon != None)', None)
    spyder.core._register_error(cls, 'assert (alpha != None) == (zeta != None)', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.nform
    if type(v) != String: v = String(v)
    ret += "%snform = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.range
    if type(v) != Range: v = Range(v)
    ret += "%srange = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.alpha
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      ret += "%salpha = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.beta
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      ret += "%sbeta = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.gamma
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      ret += "%sgamma = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.delta
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      ret += "%sdelta = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.epsilon
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      ret += "%sepsilon = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.zeta
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      ret += "%szeta = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.nform
    if type(v) != String: v = String(v)
    _d["nform"] = v.dict()
    v = self.range
    if type(v) != Range: v = Range(v)
    _d["range"] = v.dict()
    v = self.alpha
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      _d["alpha"] = v.dict()
    v = self.beta
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      _d["beta"] = v.dict()
    v = self.gamma
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      _d["gamma"] = v.dict()
    v = self.delta
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      _d["delta"] = v.dict()
    v = self.epsilon
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      _d["epsilon"] = v.dict()
    v = self.zeta
    if v != None:
      if type(v) != AngleErr: v = AngleErr(v)
      _d["zeta"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(DNABaseDihedralGroup, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(DNABaseDihedralGroup, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DNABaseDihedralGroup, target, self, deepcopy),
     name="DNABaseDihedralGroup=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,DNABaseDihedralGroup) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.range != _a.range: return False
    if self.nform != _a.nform: return False
    if self.alpha != _a.alpha: return False
    if self.beta != _a.beta: return False
    if self.gamma != _a.gamma: return False
    if self.delta != _a.delta: return False
    if self.epsilon != _a.epsilon: return False
    if self.zeta != _a.zeta: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    range = self.range
    nform = self.nform
    alpha = self.alpha
    beta = self.beta
    gamma = self.gamma
    delta = self.delta
    epsilon = self.epsilon
    zeta = self.zeta
    nform.options = "a-form", "b-form", "other"
if issubclass(Range,Spyder.String) or issubclass(Range,Spyder.Data):
  if not issubclass(DNABaseDihedralGroup,getattr(Spyder,"Degenerate")):
    raise TypeError("Spyder type 'DNABaseDihedralGroup' is degenerate: it has no more than one required member, and the first member can be constructed from a string.\nPlease change the members, or inherit explicitly from Spyder.Degenerate")
spyder.__types__["DNABaseDihedralGroup"] = DNABaseDihedralGroup
spyder.core.error["DNABaseDihedralGroup"] = {}
if hasattr(DNABaseDihedralGroup, '_register_errors'): DNABaseDihedralGroup._register_errors()
DNABaseDihedralGroup._requiredmembers = [['Range', 'range', 2]]
DNABaseDihedralGroup._defaultmembers = [['String', 'nform', '"b-form"', 1], ['AngleErr', 'alpha', 'None', 3], ['AngleErr', 'beta', 'None', 4], ['AngleErr', 'gamma', 'None', 5], ['AngleErr', 'delta', 'None', 6], ['AngleErr', 'epsilon', 'None', 7], ['AngleErr', 'zeta', 'None', 8]]
DNABaseDihedralGroup.__form__()
ResourceDNABaseDihedralGroup = spyder.__types__["_Resource"](DNABaseDihedralGroup)

DNABaseDihedralGroup.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  DNABaseDihedralGroup,
  "constructor_fromany",
)
DNABaseDihedralGroup.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  DNABaseDihedralGroup,
  "constructor_fromany",
)
DNABaseDihedralGroup.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  DNABaseDihedralGroup,
  "constructor_fromany",
)

class DNABaseDihedralGroupArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "DNABaseDihedralGroupArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, DNABaseDihedralGroupArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(DNABaseDihedralGroupArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DNABaseDihedralGroupArray, target, self,deepcopy),
     name="DNABaseDihedralGroupArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(DNABaseDihedralGroupArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != DNABaseDihedralGroup: self[vnr] = DNABaseDihedralGroup(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((DNABaseDihedralGroupArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((DNABaseDihedralGroupArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(DNABaseDihedralGroup,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a DNABaseDihedralGroupArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    DNABaseDihedralGroupArray.__dict__[DNABaseDihedralGroupArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.DNABaseDihedralGroup, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNABaseDihedralGroupArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("DNABaseDihedralGroupArray","DNABaseDihedralGroup","SPLIT")
spyder.core.defineconverter("DNABaseDihedralGroup","DNABaseDihedralGroupArray","CAST")
spyder.__types__["DNABaseDihedralGroupArray"] = globals()["DNABaseDihedralGroupArray"]  
arrayclass = spyder.__types__["DNABaseDihedralGroupArray"]
spyder.__types__["ResourceDNABaseDihedralGroupArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class DNABaseDihedralGroupArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "DNABaseDihedralGroupArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, DNABaseDihedralGroupArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(DNABaseDihedralGroupArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DNABaseDihedralGroupArrayArray, target, self,deepcopy),
     name="DNABaseDihedralGroupArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(DNABaseDihedralGroupArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != DNABaseDihedralGroup: self[vnr] = DNABaseDihedralGroup(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((DNABaseDihedralGroupArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((DNABaseDihedralGroupArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(DNABaseDihedralGroupArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a DNABaseDihedralGroupArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    DNABaseDihedralGroupArrayArray.__dict__[DNABaseDihedralGroupArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.DNABaseDihedralGroupArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNABaseDihedralGroupArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("DNABaseDihedralGroupArrayArray","DNABaseDihedralGroupArray","SPLIT")
spyder.core.defineconverter("DNABaseDihedralGroupArray","DNABaseDihedralGroupArrayArray","CAST")
spyder.__types__["DNABaseDihedralGroupArrayArray"] = globals()["DNABaseDihedralGroupArrayArray"]  
arrayclass = spyder.__types__["DNABaseDihedralGroupArrayArray"]
spyder.__types__["ResourceDNABaseDihedralGroupArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class DNA_definition(Object):
  """Spyder-generated class

 module spyder.modules.atom
 file 'DNA.spy'


  TODO documentation
  
----------------------------------------------------------------------
Spyder definition:

Type DNA_definition {
  #!#!#!
  TODO documentation
  #!#!#!
  Bool basepair_planar = True
  Bool dna_pick_wc = False
  Bool dna_pick_dih = True  
  Float wc_low = 0.05
  Float wc_up = 0.05
  Float wc_low_uri = 0.01
  Float wc_up_uri = 0.01
  Float c1_low = 0.05
  Float c1_up = 0.05    
  BasePlanarSpecification bases_planar 
  Bool dna_pick_puckdih = False  
  DNABasePuckerGroupArray puckergroup[4]  
  DNABaseDihedralGroupArray dihedralgroup[4]
  BasePairArray bp
  validate {
    assert(dna_pick_wc != basepair_planar)
    for g in puckergroup:
      mustexist = (dna_pick_pucdih == False and g.nform == "other")
      assert mustexist == (nu2 != None)
    for g in dihedralgroup:
      mustexist = (dna_pick_bacdih == False and g.nform == "other")
      assert mustexist == (alpha != None)      
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "DNA_definition"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNA_definition object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNA_definition object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    DNA_definition.__dict__[DNA_definition.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a DNA_definition object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (DNA_definition) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (DNA_definition) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (DNA_definition) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (DNA_definition) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("DNA_definition") and args[0][len("DNA_definition"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (DNA_definition) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (DNA_definition) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (DNA_definition) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, bases_planar,puckergroup,dihedralgroup,bp,basepair_planar,dna_pick_wc,dna_pick_dih,wc_low,wc_up,wc_low_uri,wc_up_uri,c1_low,c1_up,dna_pick_puckdih):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.bases_planar = reconstruct(self, BasePlanarSpecification,"bases_planar",bases_planar)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.puckergroup = reconstruct(self, DNABasePuckerGroupArray,"puckergroup",puckergroup)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.dihedralgroup = reconstruct(self, DNABaseDihedralGroupArray,"dihedralgroup",dihedralgroup)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.bp = reconstruct(self, BasePairArray,"bp",bp)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if basepair_planar is default0 or (basepair_planar.__class__ is default0.__class__ and basepair_planar == default0):      reconstruct_func = reconstruct_default
    try:
      self.basepair_planar = reconstruct_func(self, Bool,"basepair_planar",basepair_planar)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if dna_pick_wc is default0 or (dna_pick_wc.__class__ is default0.__class__ and dna_pick_wc == default0):      reconstruct_func = reconstruct_default
    try:
      self.dna_pick_wc = reconstruct_func(self, Bool,"dna_pick_wc",dna_pick_wc)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[2] if spyder.python3 else self.__unpack2__.func_defaults[2]
    if dna_pick_dih is default0 or (dna_pick_dih.__class__ is default0.__class__ and dna_pick_dih == default0):      reconstruct_func = reconstruct_default
    try:
      self.dna_pick_dih = reconstruct_func(self, Bool,"dna_pick_dih",dna_pick_dih)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[3] if spyder.python3 else self.__unpack2__.func_defaults[3]
    if wc_low is default0 or (wc_low.__class__ is default0.__class__ and wc_low == default0):      reconstruct_func = reconstruct_default
    try:
      self.wc_low = reconstruct_func(self, Float,"wc_low",wc_low)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[4] if spyder.python3 else self.__unpack2__.func_defaults[4]
    if wc_up is default0 or (wc_up.__class__ is default0.__class__ and wc_up == default0):      reconstruct_func = reconstruct_default
    try:
      self.wc_up = reconstruct_func(self, Float,"wc_up",wc_up)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[5] if spyder.python3 else self.__unpack2__.func_defaults[5]
    if wc_low_uri is default0 or (wc_low_uri.__class__ is default0.__class__ and wc_low_uri == default0):      reconstruct_func = reconstruct_default
    try:
      self.wc_low_uri = reconstruct_func(self, Float,"wc_low_uri",wc_low_uri)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[6] if spyder.python3 else self.__unpack2__.func_defaults[6]
    if wc_up_uri is default0 or (wc_up_uri.__class__ is default0.__class__ and wc_up_uri == default0):      reconstruct_func = reconstruct_default
    try:
      self.wc_up_uri = reconstruct_func(self, Float,"wc_up_uri",wc_up_uri)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[7] if spyder.python3 else self.__unpack2__.func_defaults[7]
    if c1_low is default0 or (c1_low.__class__ is default0.__class__ and c1_low == default0):      reconstruct_func = reconstruct_default
    try:
      self.c1_low = reconstruct_func(self, Float,"c1_low",c1_low)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[8] if spyder.python3 else self.__unpack2__.func_defaults[8]
    if c1_up is default0 or (c1_up.__class__ is default0.__class__ and c1_up == default0):      reconstruct_func = reconstruct_default
    try:
      self.c1_up = reconstruct_func(self, Float,"c1_up",c1_up)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[9] if spyder.python3 else self.__unpack2__.func_defaults[9]
    if dna_pick_puckdih is default0 or (dna_pick_puckdih.__class__ is default0.__class__ and dna_pick_puckdih == default0):      reconstruct_func = reconstruct_default
    try:
      self.dna_pick_puckdih = reconstruct_func(self, Bool,"dna_pick_puckdih",dna_pick_puckdih)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("bases_planar","puckergroup","dihedralgroup","bp")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,bases_planar,puckergroup,dihedralgroup,bp,basepair_planar=True,dna_pick_wc=False,dna_pick_dih=True,wc_low=0.05,wc_up=0.05,wc_low_uri=0.01,wc_up_uri=0.01,c1_low=0.05,c1_up=0.05,dna_pick_puckdih=False,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return bases_planar,puckergroup,dihedralgroup,bp,basepair_planar,dna_pick_wc,dna_pick_dih,wc_low,wc_up,wc_low_uri,wc_up_uri,c1_low,c1_up,dna_pick_puckdih
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      bases_planar = _a.bases_planar
    except AttributeError:
      _missing_members.append('bases_planar')
    try:
      puckergroup = _a.puckergroup
    except AttributeError:
      _missing_members.append('puckergroup')
    try:
      dihedralgroup = _a.dihedralgroup
    except AttributeError:
      _missing_members.append('dihedralgroup')
    try:
      bp = _a.bp
    except AttributeError:
      _missing_members.append('bp')
    basepair_planar = True
    if hasattr(_a,"basepair_planar") and _a.basepair_planar != None: basepair_planar = _a.basepair_planar
    dna_pick_wc = False
    if hasattr(_a,"dna_pick_wc") and _a.dna_pick_wc != None: dna_pick_wc = _a.dna_pick_wc
    dna_pick_dih = True
    if hasattr(_a,"dna_pick_dih") and _a.dna_pick_dih != None: dna_pick_dih = _a.dna_pick_dih
    wc_low = 0.05
    if hasattr(_a,"wc_low") and _a.wc_low != None: wc_low = _a.wc_low
    wc_up = 0.05
    if hasattr(_a,"wc_up") and _a.wc_up != None: wc_up = _a.wc_up
    wc_low_uri = 0.01
    if hasattr(_a,"wc_low_uri") and _a.wc_low_uri != None: wc_low_uri = _a.wc_low_uri
    wc_up_uri = 0.01
    if hasattr(_a,"wc_up_uri") and _a.wc_up_uri != None: wc_up_uri = _a.wc_up_uri
    c1_low = 0.05
    if hasattr(_a,"c1_low") and _a.c1_low != None: c1_low = _a.c1_low
    c1_up = 0.05
    if hasattr(_a,"c1_up") and _a.c1_up != None: c1_up = _a.c1_up
    dna_pick_puckdih = False
    if hasattr(_a,"dna_pick_puckdih") and _a.dna_pick_puckdih != None: dna_pick_puckdih = _a.dna_pick_puckdih
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (bases_planar,puckergroup,dihedralgroup,bp,basepair_planar,dna_pick_wc,dna_pick_dih,wc_low,wc_up,wc_low_uri,wc_up_uri,c1_low,c1_up,dna_pick_puckdih,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      bases_planar = _a['bases_planar']
    except KeyError:
      _missing_members.append('bases_planar')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      puckergroup = _a['puckergroup']
    except KeyError:
      _missing_members.append('puckergroup')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      dihedralgroup = _a['dihedralgroup']
    except KeyError:
      _missing_members.append('dihedralgroup')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      bp = _a['bp']
    except KeyError:
      _missing_members.append('bp')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    basepair_planar = True
    if "basepair_planar" in _a: basepair_planar = _a["basepair_planar"]
    if isinstance(_a, dict) and "basepair_planar" in _a: basepair_planar = _a["basepair_planar"]
    dna_pick_wc = False
    if "dna_pick_wc" in _a: dna_pick_wc = _a["dna_pick_wc"]
    if isinstance(_a, dict) and "dna_pick_wc" in _a: dna_pick_wc = _a["dna_pick_wc"]
    dna_pick_dih = True
    if "dna_pick_dih" in _a: dna_pick_dih = _a["dna_pick_dih"]
    if isinstance(_a, dict) and "dna_pick_dih" in _a: dna_pick_dih = _a["dna_pick_dih"]
    wc_low = 0.05
    if "wc_low" in _a: wc_low = _a["wc_low"]
    if isinstance(_a, dict) and "wc_low" in _a: wc_low = _a["wc_low"]
    wc_up = 0.05
    if "wc_up" in _a: wc_up = _a["wc_up"]
    if isinstance(_a, dict) and "wc_up" in _a: wc_up = _a["wc_up"]
    wc_low_uri = 0.01
    if "wc_low_uri" in _a: wc_low_uri = _a["wc_low_uri"]
    if isinstance(_a, dict) and "wc_low_uri" in _a: wc_low_uri = _a["wc_low_uri"]
    wc_up_uri = 0.01
    if "wc_up_uri" in _a: wc_up_uri = _a["wc_up_uri"]
    if isinstance(_a, dict) and "wc_up_uri" in _a: wc_up_uri = _a["wc_up_uri"]
    c1_low = 0.05
    if "c1_low" in _a: c1_low = _a["c1_low"]
    if isinstance(_a, dict) and "c1_low" in _a: c1_low = _a["c1_low"]
    c1_up = 0.05
    if "c1_up" in _a: c1_up = _a["c1_up"]
    if isinstance(_a, dict) and "c1_up" in _a: c1_up = _a["c1_up"]
    dna_pick_puckdih = False
    if "dna_pick_puckdih" in _a: dna_pick_puckdih = _a["dna_pick_puckdih"]
    if isinstance(_a, dict) and "dna_pick_puckdih" in _a: dna_pick_puckdih = _a["dna_pick_puckdih"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (bases_planar,puckergroup,dihedralgroup,bp,basepair_planar,dna_pick_wc,dna_pick_dih,wc_low,wc_up,wc_low_uri,wc_up_uri,c1_low,c1_up,dna_pick_puckdih,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.bases_planar = BasePlanarSpecification(self.bases_planar)
      self.puckergroup = DNABasePuckerGroupArray(self.puckergroup)
      self.dihedralgroup = DNABaseDihedralGroupArray(self.dihedralgroup)
      self.bp = BasePairArray(self.bp)
      self.basepair_planar = Bool(self.basepair_planar)
      self.dna_pick_wc = Bool(self.dna_pick_wc)
      self.dna_pick_dih = Bool(self.dna_pick_dih)
      self.wc_low = Float(self.wc_low)
      self.wc_up = Float(self.wc_up)
      self.wc_low_uri = Float(self.wc_low_uri)
      self.wc_up_uri = Float(self.wc_up_uri)
      self.c1_low = Float(self.c1_low)
      self.c1_up = Float(self.c1_up)
      self.dna_pick_puckdih = Bool(self.dna_pick_puckdih)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    bases_planar = self.bases_planar
    puckergroup = self.puckergroup
    dihedralgroup = self.dihedralgroup
    bp = self.bp
    basepair_planar = self.basepair_planar
    dna_pick_wc = self.dna_pick_wc
    dna_pick_dih = self.dna_pick_dih
    wc_low = self.wc_low
    wc_up = self.wc_up
    wc_low_uri = self.wc_low_uri
    wc_up_uri = self.wc_up_uri
    c1_low = self.c1_low
    c1_up = self.c1_up
    dna_pick_puckdih = self.dna_pick_puckdih
    spyder.core._assert(self, 'puckergroup == None or len(puckergroup) == 4', 'assert puckergroup == None or len(puckergroup) == 4')
    spyder.core._assert(self, 'dihedralgroup == None or len(dihedralgroup) == 4', 'assert dihedralgroup == None or len(dihedralgroup) == 4')
    assert(dna_pick_wc != basepair_planar)
    for g in puckergroup:
      mustexist = (dna_pick_pucdih == False and g.nform == "other")
      spyder.core._assert(self, 'mustexist == (nu2 != None)', 'assert mustexist == (nu2 != None)')
    for g in dihedralgroup:
      mustexist = (dna_pick_bacdih == False and g.nform == "other")
      spyder.core._assert(self, 'mustexist == (alpha != None)', 'assert mustexist == (alpha != None)')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'assert puckergroup == None or len(puckergroup) == 4', None)
    spyder.core._register_error(cls, 'assert dihedralgroup == None or len(dihedralgroup) == 4', None)
    spyder.core._register_error(cls, 'assert mustexist == (nu2 != None)', None)
    spyder.core._register_error(cls, 'assert mustexist == (alpha != None)', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.basepair_planar
    if type(v) != Bool: v = Bool(v)
    ret += "%sbasepair_planar = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.dna_pick_wc
    if type(v) != Bool: v = Bool(v)
    ret += "%sdna_pick_wc = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.dna_pick_dih
    if type(v) != Bool: v = Bool(v)
    ret += "%sdna_pick_dih = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.wc_low
    if type(v) != Float: v = Float(v)
    ret += "%swc_low = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.wc_up
    if type(v) != Float: v = Float(v)
    ret += "%swc_up = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.wc_low_uri
    if type(v) != Float: v = Float(v)
    ret += "%swc_low_uri = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.wc_up_uri
    if type(v) != Float: v = Float(v)
    ret += "%swc_up_uri = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.c1_low
    if type(v) != Float: v = Float(v)
    ret += "%sc1_low = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.c1_up
    if type(v) != Float: v = Float(v)
    ret += "%sc1_up = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.bases_planar
    if type(v) != BasePlanarSpecification: v = BasePlanarSpecification(v)
    ret += "%sbases_planar = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.dna_pick_puckdih
    if type(v) != Bool: v = Bool(v)
    ret += "%sdna_pick_puckdih = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.puckergroup
    if type(v) != DNABasePuckerGroupArray: v = DNABasePuckerGroupArray(v)
    ret += "%spuckergroup = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.dihedralgroup
    if type(v) != DNABaseDihedralGroupArray: v = DNABaseDihedralGroupArray(v)
    ret += "%sdihedralgroup = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.bp
    if type(v) != BasePairArray: v = BasePairArray(v)
    ret += "%sbp = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.basepair_planar
    if type(v) != Bool: v = Bool(v)
    _d["basepair_planar"] = v.dict()
    v = self.dna_pick_wc
    if type(v) != Bool: v = Bool(v)
    _d["dna_pick_wc"] = v.dict()
    v = self.dna_pick_dih
    if type(v) != Bool: v = Bool(v)
    _d["dna_pick_dih"] = v.dict()
    v = self.wc_low
    if type(v) != Float: v = Float(v)
    _d["wc_low"] = v.dict()
    v = self.wc_up
    if type(v) != Float: v = Float(v)
    _d["wc_up"] = v.dict()
    v = self.wc_low_uri
    if type(v) != Float: v = Float(v)
    _d["wc_low_uri"] = v.dict()
    v = self.wc_up_uri
    if type(v) != Float: v = Float(v)
    _d["wc_up_uri"] = v.dict()
    v = self.c1_low
    if type(v) != Float: v = Float(v)
    _d["c1_low"] = v.dict()
    v = self.c1_up
    if type(v) != Float: v = Float(v)
    _d["c1_up"] = v.dict()
    v = self.bases_planar
    if type(v) != BasePlanarSpecification: v = BasePlanarSpecification(v)
    _d["bases_planar"] = v.dict()
    v = self.dna_pick_puckdih
    if type(v) != Bool: v = Bool(v)
    _d["dna_pick_puckdih"] = v.dict()
    v = self.puckergroup
    if type(v) != DNABasePuckerGroupArray: v = DNABasePuckerGroupArray(v)
    _d["puckergroup"] = v.dict()
    v = self.dihedralgroup
    if type(v) != DNABaseDihedralGroupArray: v = DNABaseDihedralGroupArray(v)
    _d["dihedralgroup"] = v.dict()
    v = self.bp
    if type(v) != BasePairArray: v = BasePairArray(v)
    _d["bp"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(DNA_definition, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(DNA_definition, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DNA_definition, target, self, deepcopy),
     name="DNA_definition=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,DNA_definition) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.bases_planar != _a.bases_planar: return False
    if self.puckergroup != _a.puckergroup: return False
    if self.dihedralgroup != _a.dihedralgroup: return False
    if self.bp != _a.bp: return False
    if self.basepair_planar != _a.basepair_planar: return False
    if self.dna_pick_wc != _a.dna_pick_wc: return False
    if self.dna_pick_dih != _a.dna_pick_dih: return False
    if self.wc_low != _a.wc_low: return False
    if self.wc_up != _a.wc_up: return False
    if self.wc_low_uri != _a.wc_low_uri: return False
    if self.wc_up_uri != _a.wc_up_uri: return False
    if self.c1_low != _a.c1_low: return False
    if self.c1_up != _a.c1_up: return False
    if self.dna_pick_puckdih != _a.dna_pick_puckdih: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    bases_planar = self.bases_planar
    puckergroup = self.puckergroup
    dihedralgroup = self.dihedralgroup
    bp = self.bp
    basepair_planar = self.basepair_planar
    dna_pick_wc = self.dna_pick_wc
    dna_pick_dih = self.dna_pick_dih
    wc_low = self.wc_low
    wc_up = self.wc_up
    wc_low_uri = self.wc_low_uri
    wc_up_uri = self.wc_up_uri
    c1_low = self.c1_low
    c1_up = self.c1_up
    dna_pick_puckdih = self.dna_pick_puckdih
    puckergroup.length = 4
    puckergroup.form = "hard"
    dihedralgroup.length = 4
    dihedralgroup.form = "hard"
    bp.type = "text"
spyder.__types__["DNA_definition"] = DNA_definition
spyder.core.error["DNA_definition"] = {}
if hasattr(DNA_definition, '_register_errors'): DNA_definition._register_errors()
DNA_definition._requiredmembers = [['BasePlanarSpecification', 'bases_planar', 10], ['DNABasePuckerGroupArray', 'puckergroup', 12], ['DNABaseDihedralGroupArray', 'dihedralgroup', 13], ['BasePairArray', 'bp', 14]]
DNA_definition._defaultmembers = [['Bool', 'basepair_planar', 'True', 1], ['Bool', 'dna_pick_wc', 'False', 2], ['Bool', 'dna_pick_dih', 'True', 3], ['Float', 'wc_low', '0.05', 4], ['Float', 'wc_up', '0.05', 5], ['Float', 'wc_low_uri', '0.01', 6], ['Float', 'wc_up_uri', '0.01', 7], ['Float', 'c1_low', '0.05', 8], ['Float', 'c1_up', '0.05', 9], ['Bool', 'dna_pick_puckdih', 'False', 11]]
DNA_definition.__form__()
ResourceDNA_definition = spyder.__types__["_Resource"](DNA_definition)

DNA_definition.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  DNA_definition,
  "constructor_fromany",
)
DNA_definition.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  DNA_definition,
  "constructor_fromany",
)
DNA_definition.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  DNA_definition,
  "constructor_fromany",
)

class DNA_definitionArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "DNA_definitionArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, DNA_definitionArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(DNA_definitionArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DNA_definitionArray, target, self,deepcopy),
     name="DNA_definitionArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(DNA_definitionArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != DNA_definition: self[vnr] = DNA_definition(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((DNA_definitionArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((DNA_definitionArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(DNA_definition,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a DNA_definitionArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    DNA_definitionArray.__dict__[DNA_definitionArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.DNA_definition, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNA_definitionArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("DNA_definitionArray","DNA_definition","SPLIT")
spyder.core.defineconverter("DNA_definition","DNA_definitionArray","CAST")
spyder.__types__["DNA_definitionArray"] = globals()["DNA_definitionArray"]  
arrayclass = spyder.__types__["DNA_definitionArray"]
spyder.__types__["ResourceDNA_definitionArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class DNA_definitionArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "DNA_definitionArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, DNA_definitionArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(DNA_definitionArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DNA_definitionArrayArray, target, self,deepcopy),
     name="DNA_definitionArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(DNA_definitionArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != DNA_definition: self[vnr] = DNA_definition(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((DNA_definitionArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((DNA_definitionArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(DNA_definitionArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a DNA_definitionArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    DNA_definitionArrayArray.__dict__[DNA_definitionArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.DNA_definitionArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DNA_definitionArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("DNA_definitionArrayArray","DNA_definitionArray","SPLIT")
spyder.core.defineconverter("DNA_definitionArray","DNA_definitionArrayArray","CAST")
spyder.__types__["DNA_definitionArrayArray"] = globals()["DNA_definitionArrayArray"]  
arrayclass = spyder.__types__["DNA_definitionArrayArray"]
spyder.__types__["ResourceDNA_definitionArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()

