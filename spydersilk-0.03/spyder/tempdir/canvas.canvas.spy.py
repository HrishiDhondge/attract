
class Box2D(Object):
  """Spyder-generated class

 module spyder.modules.canvas
 file 'canvas.spy'


----------------------------------------------------------------------
Spyder definition:

Type Box2D {
  Integer x
  Integer y
  Integer sizex
  Integer sizey
  Enum mode("pixels","standard","aspect") = "pixels"
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Box2D"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Box2D object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Box2D object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Box2D.__dict__[Box2D.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Box2D object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Box2D) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Box2D) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Box2D) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Box2D) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Box2D") and args[0][len("Box2D"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Box2D) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Box2D) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Box2D) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, x,y,sizex,sizey,mode):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.x = reconstruct(self, Integer,"x",x)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.y = reconstruct(self, Integer,"y",y)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.sizex = reconstruct(self, Integer,"sizex",sizex)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.sizey = reconstruct(self, Integer,"sizey",sizey)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if mode is default0 or (mode.__class__ is default0.__class__ and mode == default0):      reconstruct_func = reconstruct_default
    try:
      self.mode = reconstruct_func(self, String,"mode",mode)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("x","y","sizex","sizey")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,x,y,sizex,sizey,mode="pixels",*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return x,y,sizex,sizey,mode
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a.x
    except AttributeError:
      _missing_members.append('x')
    try:
      y = _a.y
    except AttributeError:
      _missing_members.append('y')
    try:
      sizex = _a.sizex
    except AttributeError:
      _missing_members.append('sizex')
    try:
      sizey = _a.sizey
    except AttributeError:
      _missing_members.append('sizey')
    mode = "pixels"
    if hasattr(_a,"mode") and _a.mode != None: mode = _a.mode
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (x,y,sizex,sizey,mode,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a['x']
    except KeyError:
      _missing_members.append('x')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      y = _a['y']
    except KeyError:
      _missing_members.append('y')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      sizex = _a['sizex']
    except KeyError:
      _missing_members.append('sizex')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      sizey = _a['sizey']
    except KeyError:
      _missing_members.append('sizey')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    mode = "pixels"
    if "mode" in _a: mode = _a["mode"]
    if isinstance(_a, dict) and "mode" in _a: mode = _a["mode"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (x,y,sizex,sizey,mode,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.x = Integer(self.x)
      self.y = Integer(self.y)
      self.sizex = Integer(self.sizex)
      self.sizey = Integer(self.sizey)
      self.mode = String(self.mode)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    x = self.x
    y = self.y
    sizex = self.sizex
    sizey = self.sizey
    mode = self.mode
    if mode is not None: spyder.core._assert(self, 'mode in ("pixels","standard","aspect")', 'if mode is not None: assert mode in ("pixels","standard","aspect")')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'if mode is not None: assert mode in ("pixels","standard","aspect")', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.x
    if type(v) != Integer: v = Integer(v)
    ret += "%sx = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.y
    if type(v) != Integer: v = Integer(v)
    ret += "%sy = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.sizex
    if type(v) != Integer: v = Integer(v)
    ret += "%ssizex = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.sizey
    if type(v) != Integer: v = Integer(v)
    ret += "%ssizey = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.mode
    if type(v) != String: v = String(v)
    ret += "%smode = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.x
    if type(v) != Integer: v = Integer(v)
    _d["x"] = v.dict()
    v = self.y
    if type(v) != Integer: v = Integer(v)
    _d["y"] = v.dict()
    v = self.sizex
    if type(v) != Integer: v = Integer(v)
    _d["sizex"] = v.dict()
    v = self.sizey
    if type(v) != Integer: v = Integer(v)
    _d["sizey"] = v.dict()
    v = self.mode
    if type(v) != String: v = String(v)
    _d["mode"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Box2D, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Box2D, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Box2D, target, self, deepcopy),
     name="Box2D=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Box2D) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.x != _a.x: return False
    if self.y != _a.y: return False
    if self.sizex != _a.sizex: return False
    if self.sizey != _a.sizey: return False
    if self.mode != _a.mode: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    x = self.x
    y = self.y
    sizex = self.sizex
    sizey = self.sizey
    mode = self.mode
    mode.options = "pixels","standard","aspect"
spyder.__types__["Box2D"] = Box2D
spyder.core.error["Box2D"] = {}
if hasattr(Box2D, '_register_errors'): Box2D._register_errors()
Box2D._requiredmembers = [['Integer', 'x', 1], ['Integer', 'y', 2], ['Integer', 'sizex', 3], ['Integer', 'sizey', 4]]
Box2D._defaultmembers = [['String', 'mode', '"pixels"', 5]]
Box2D.__form__()
ResourceBox2D = spyder.__types__["_Resource"](Box2D)

Box2D.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Box2D,
  "constructor_fromany",
)
Box2D.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Box2D,
  "constructor_fromany",
)
Box2D.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Box2D,
  "constructor_fromany",
)

class Box2DArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Box2DArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Box2DArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Box2DArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Box2DArray, target, self,deepcopy),
     name="Box2DArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Box2DArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Box2D: self[vnr] = Box2D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Box2DArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Box2DArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Box2D,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Box2DArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Box2DArray.__dict__[Box2DArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Box2D, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Box2DArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Box2DArray","Box2D","SPLIT")
spyder.core.defineconverter("Box2D","Box2DArray","CAST")
spyder.__types__["Box2DArray"] = globals()["Box2DArray"]  
arrayclass = spyder.__types__["Box2DArray"]
spyder.__types__["ResourceBox2DArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Box2DArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Box2DArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Box2DArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Box2DArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Box2DArrayArray, target, self,deepcopy),
     name="Box2DArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Box2DArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Box2D: self[vnr] = Box2D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Box2DArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Box2DArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Box2DArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Box2DArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Box2DArrayArray.__dict__[Box2DArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Box2DArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Box2DArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Box2DArrayArray","Box2DArray","SPLIT")
spyder.core.defineconverter("Box2DArray","Box2DArrayArray","CAST")
spyder.__types__["Box2DArrayArray"] = globals()["Box2DArrayArray"]  
arrayclass = spyder.__types__["Box2DArrayArray"]
spyder.__types__["ResourceBox2DArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Image(Object):
  """Spyder-generated class

 module spyder.modules.canvas
 file 'canvas.spy'


----------------------------------------------------------------------
Spyder definition:

Type Image {
  String image
  String identifier
  Box2D box  
  Bool transparency = False
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Image"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Image object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Image object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Image.__dict__[Image.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Image object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Image) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Image) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Image) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Image) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Image") and args[0][len("Image"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Image) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Image) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Image) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, image,identifier,box,transparency):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.image = reconstruct(self, String,"image",image)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.identifier = reconstruct(self, String,"identifier",identifier)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.box = reconstruct(self, Box2D,"box",box)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if transparency is default0 or (transparency.__class__ is default0.__class__ and transparency == default0):      reconstruct_func = reconstruct_default
    try:
      self.transparency = reconstruct_func(self, Bool,"transparency",transparency)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("image","identifier","box")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,image,identifier,box,transparency=False,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return image,identifier,box,transparency
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      image = _a.image
    except AttributeError:
      _missing_members.append('image')
    try:
      identifier = _a.identifier
    except AttributeError:
      _missing_members.append('identifier')
    try:
      box = _a.box
    except AttributeError:
      _missing_members.append('box')
    transparency = False
    if hasattr(_a,"transparency") and _a.transparency != None: transparency = _a.transparency
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (image,identifier,box,transparency,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      image = _a['image']
    except KeyError:
      _missing_members.append('image')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      identifier = _a['identifier']
    except KeyError:
      _missing_members.append('identifier')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      box = _a['box']
    except KeyError:
      _missing_members.append('box')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    transparency = False
    if "transparency" in _a: transparency = _a["transparency"]
    if isinstance(_a, dict) and "transparency" in _a: transparency = _a["transparency"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (image,identifier,box,transparency,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.image = String(self.image)
      self.identifier = String(self.identifier)
      self.box = Box2D(self.box)
      self.transparency = Bool(self.transparency)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.image
    if type(v) != String: v = String(v)
    ret += "%simage = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.identifier
    if type(v) != String: v = String(v)
    ret += "%sidentifier = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.box
    if type(v) != Box2D: v = Box2D(v)
    ret += "%sbox = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.transparency
    if type(v) != Bool: v = Bool(v)
    ret += "%stransparency = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.image
    if type(v) != String: v = String(v)
    _d["image"] = v.dict()
    v = self.identifier
    if type(v) != String: v = String(v)
    _d["identifier"] = v.dict()
    v = self.box
    if type(v) != Box2D: v = Box2D(v)
    _d["box"] = v.dict()
    v = self.transparency
    if type(v) != Bool: v = Bool(v)
    _d["transparency"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Image, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Image, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Image, target, self, deepcopy),
     name="Image=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Image) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.image != _a.image: return False
    if self.identifier != _a.identifier: return False
    if self.box != _a.box: return False
    if self.transparency != _a.transparency: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Image"] = Image
spyder.core.error["Image"] = {}
if hasattr(Image, '_register_errors'): Image._register_errors()
Image._requiredmembers = [['String', 'image', 1], ['String', 'identifier', 2], ['Box2D', 'box', 3]]
Image._defaultmembers = [['Bool', 'transparency', 'False', 4]]
Image.__form__()
ResourceImage = spyder.__types__["_Resource"](Image)

Image.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Image,
  "constructor_fromany",
)
Image.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Image,
  "constructor_fromany",
)
Image.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Image,
  "constructor_fromany",
)

class ImageArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "ImageArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, ImageArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(ImageArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (ImageArray, target, self,deepcopy),
     name="ImageArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(ImageArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Image: self[vnr] = Image(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((ImageArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((ImageArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Image,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a ImageArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    ImageArray.__dict__[ImageArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Image, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a ImageArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("ImageArray","Image","SPLIT")
spyder.core.defineconverter("Image","ImageArray","CAST")
spyder.__types__["ImageArray"] = globals()["ImageArray"]  
arrayclass = spyder.__types__["ImageArray"]
spyder.__types__["ResourceImageArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class ImageArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "ImageArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, ImageArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(ImageArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (ImageArrayArray, target, self,deepcopy),
     name="ImageArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(ImageArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Image: self[vnr] = Image(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((ImageArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((ImageArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(ImageArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a ImageArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    ImageArrayArray.__dict__[ImageArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.ImageArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a ImageArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("ImageArrayArray","ImageArray","SPLIT")
spyder.core.defineconverter("ImageArray","ImageArrayArray","CAST")
spyder.__types__["ImageArrayArray"] = globals()["ImageArrayArray"]  
arrayclass = spyder.__types__["ImageArrayArray"]
spyder.__types__["ResourceImageArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class MouseArea(Object):
  """Spyder-generated class

 module spyder.modules.canvas
 file 'canvas.spy'


----------------------------------------------------------------------
Spyder definition:

Type MouseArea {
  String identifier
  Box2D box
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "MouseArea"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a MouseArea object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a MouseArea object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    MouseArea.__dict__[MouseArea.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a MouseArea object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (MouseArea) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (MouseArea) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (MouseArea) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (MouseArea) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("MouseArea") and args[0][len("MouseArea"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (MouseArea) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (MouseArea) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (MouseArea) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, identifier,box):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.identifier = reconstruct(self, String,"identifier",identifier)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.box = reconstruct(self, Box2D,"box",box)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("identifier","box")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,identifier,box,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return identifier,box
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      identifier = _a.identifier
    except AttributeError:
      _missing_members.append('identifier')
    try:
      box = _a.box
    except AttributeError:
      _missing_members.append('box')
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (identifier,box,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      identifier = _a['identifier']
    except KeyError:
      _missing_members.append('identifier')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      box = _a['box']
    except KeyError:
      _missing_members.append('box')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (identifier,box,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.identifier = String(self.identifier)
      self.box = Box2D(self.box)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.identifier
    if type(v) != String: v = String(v)
    ret += "%sidentifier = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.box
    if type(v) != Box2D: v = Box2D(v)
    ret += "%sbox = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.identifier
    if type(v) != String: v = String(v)
    _d["identifier"] = v.dict()
    v = self.box
    if type(v) != Box2D: v = Box2D(v)
    _d["box"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(MouseArea, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(MouseArea, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (MouseArea, target, self, deepcopy),
     name="MouseArea=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,MouseArea) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.identifier != _a.identifier: return False
    if self.box != _a.box: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["MouseArea"] = MouseArea
spyder.core.error["MouseArea"] = {}
if hasattr(MouseArea, '_register_errors'): MouseArea._register_errors()
MouseArea._requiredmembers = [['String', 'identifier', 1], ['Box2D', 'box', 2]]
MouseArea._defaultmembers = []
MouseArea.__form__()
ResourceMouseArea = spyder.__types__["_Resource"](MouseArea)

MouseArea.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  MouseArea,
  "constructor_fromany",
)
MouseArea.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  MouseArea,
  "constructor_fromany",
)
MouseArea.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  MouseArea,
  "constructor_fromany",
)

class MouseAreaArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "MouseAreaArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, MouseAreaArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(MouseAreaArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (MouseAreaArray, target, self,deepcopy),
     name="MouseAreaArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(MouseAreaArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != MouseArea: self[vnr] = MouseArea(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((MouseAreaArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((MouseAreaArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(MouseArea,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a MouseAreaArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    MouseAreaArray.__dict__[MouseAreaArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.MouseArea, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a MouseAreaArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("MouseAreaArray","MouseArea","SPLIT")
spyder.core.defineconverter("MouseArea","MouseAreaArray","CAST")
spyder.__types__["MouseAreaArray"] = globals()["MouseAreaArray"]  
arrayclass = spyder.__types__["MouseAreaArray"]
spyder.__types__["ResourceMouseAreaArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class MouseAreaArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "MouseAreaArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, MouseAreaArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(MouseAreaArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (MouseAreaArrayArray, target, self,deepcopy),
     name="MouseAreaArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(MouseAreaArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != MouseArea: self[vnr] = MouseArea(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((MouseAreaArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((MouseAreaArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(MouseAreaArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a MouseAreaArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    MouseAreaArrayArray.__dict__[MouseAreaArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.MouseAreaArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a MouseAreaArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("MouseAreaArrayArray","MouseAreaArray","SPLIT")
spyder.core.defineconverter("MouseAreaArray","MouseAreaArrayArray","CAST")
spyder.__types__["MouseAreaArrayArray"] = globals()["MouseAreaArrayArray"]  
arrayclass = spyder.__types__["MouseAreaArrayArray"]
spyder.__types__["ResourceMouseAreaArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Icon(Image):
  """Spyder-generated class

 module spyder.modules.canvas
 file 'canvas.spy'


----------------------------------------------------------------------
Spyder definition:

Type Icon(Image) {
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Icon"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Icon object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Icon object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Icon.__dict__[Icon.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Icon object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Icon) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Icon) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Icon) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Icon) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Icon") and args[0][len("Icon"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Icon) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Icon) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Icon) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, image,identifier,box,transparency):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.image = reconstruct(self, String,"image",image)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.identifier = reconstruct(self, String,"identifier",identifier)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.box = reconstruct(self, Box2D,"box",box)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if transparency is default0 or (transparency.__class__ is default0.__class__ and transparency == default0):      reconstruct_func = reconstruct_default
    try:
      self.transparency = reconstruct_func(self, Bool,"transparency",transparency)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("image","identifier","box")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,image,identifier,box,transparency=False,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return image,identifier,box,transparency
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      image = _a.image
    except AttributeError:
      _missing_members.append('image')
    try:
      identifier = _a.identifier
    except AttributeError:
      _missing_members.append('identifier')
    try:
      box = _a.box
    except AttributeError:
      _missing_members.append('box')
    transparency = False
    if hasattr(_a,"transparency") and _a.transparency != None: transparency = _a.transparency
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (image,identifier,box,transparency,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      image = _a['image']
    except KeyError:
      _missing_members.append('image')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      identifier = _a['identifier']
    except KeyError:
      _missing_members.append('identifier')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      box = _a['box']
    except KeyError:
      _missing_members.append('box')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    transparency = False
    if "transparency" in _a: transparency = _a["transparency"]
    if isinstance(_a, dict) and "transparency" in _a: transparency = _a["transparency"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (image,identifier,box,transparency,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.image = String(self.image)
      self.identifier = String(self.identifier)
      self.box = Box2D(self.box)
      self.transparency = Bool(self.transparency)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.image
    if type(v) != String: v = String(v)
    ret += "%simage = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.identifier
    if type(v) != String: v = String(v)
    ret += "%sidentifier = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.box
    if type(v) != Box2D: v = Box2D(v)
    ret += "%sbox = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.transparency
    if type(v) != Bool: v = Bool(v)
    ret += "%stransparency = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.image
    if type(v) != String: v = String(v)
    _d["image"] = v.dict()
    v = self.identifier
    if type(v) != String: v = String(v)
    _d["identifier"] = v.dict()
    v = self.box
    if type(v) != Box2D: v = Box2D(v)
    _d["box"] = v.dict()
    v = self.transparency
    if type(v) != Bool: v = Bool(v)
    _d["transparency"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Icon, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Icon, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Icon, target, self, deepcopy),
     name="Icon=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Icon) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.image != _a.image: return False
    if self.identifier != _a.identifier: return False
    if self.box != _a.box: return False
    if self.transparency != _a.transparency: return False
    try:
      if not Image.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Icon"] = Icon
spyder.core.error["Icon"] = {}
if hasattr(Icon, '_register_errors'): Icon._register_errors()
Icon._requiredmembers = [['String', 'image', 1], ['String', 'identifier', 2], ['Box2D', 'box', 3]]
Icon._defaultmembers = [['Bool', 'transparency', 'False', 4]]
Icon.__form__()
ResourceIcon = spyder.__types__["_Resource"](Icon)

Icon.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Icon,
  "constructor_fromany",
)
Icon.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Icon,
  "constructor_fromany",
)
Icon.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Icon,
  "constructor_fromany",
)

class IconArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "IconArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, IconArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(IconArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (IconArray, target, self,deepcopy),
     name="IconArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(IconArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Icon: self[vnr] = Icon(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((IconArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((IconArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Icon,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a IconArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    IconArray.__dict__[IconArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Icon, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a IconArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("IconArray","Icon","SPLIT")
spyder.core.defineconverter("Icon","IconArray","CAST")
spyder.__types__["IconArray"] = globals()["IconArray"]  
arrayclass = spyder.__types__["IconArray"]
spyder.__types__["ResourceIconArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class IconArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "IconArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, IconArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(IconArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (IconArrayArray, target, self,deepcopy),
     name="IconArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(IconArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Icon: self[vnr] = Icon(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((IconArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((IconArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(IconArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a IconArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    IconArrayArray.__dict__[IconArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.IconArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a IconArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("IconArrayArray","IconArray","SPLIT")
spyder.core.defineconverter("IconArray","IconArrayArray","CAST")
spyder.__types__["IconArrayArray"] = globals()["IconArrayArray"]  
arrayclass = spyder.__types__["IconArrayArray"]
spyder.__types__["ResourceIconArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()

"""Define ObjectList(Icon i) {
  im = Image(i)
  ar = MouseArea(i.identifier,i.box)
  return [im, ar]
}"""
def spyderconverterfunction_27(i):
  im = Image(i)
  ar = MouseArea(i.identifier,i.box)
  return [im, ar]

spyder.core.defineconverter("Icon","ObjectList",spyderconverterfunction_27)

del spyderconverterfunction_27
