
class Coordinate2D(Object):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type Coordinate2D {
  Float x
  Float y
  form {
    x.default = 0
    y.default = 0    
    x.digits = 3
    y.digits = 3
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Coordinate2D"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Coordinate2D object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Coordinate2D object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Coordinate2D.__dict__[Coordinate2D.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Coordinate2D object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Coordinate2D) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Coordinate2D) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Coordinate2D) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Coordinate2D) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Coordinate2D") and args[0][len("Coordinate2D"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Coordinate2D) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Coordinate2D) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Coordinate2D) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, x,y):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.x = reconstruct(self, Float,"x",x)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.y = reconstruct(self, Float,"y",y)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("x","y")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,x,y,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return x,y
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a.x
    except AttributeError:
      _missing_members.append('x')
    try:
      y = _a.y
    except AttributeError:
      _missing_members.append('y')
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (x,y,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a['x']
    except KeyError:
      _missing_members.append('x')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      y = _a['y']
    except KeyError:
      _missing_members.append('y')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (x,y,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.x = Float(self.x)
      self.y = Float(self.y)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.x
    if type(v) != Float: v = Float(v)
    ret += "%sx = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.y
    if type(v) != Float: v = Float(v)
    ret += "%sy = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.x
    if type(v) != Float: v = Float(v)
    _d["x"] = v.dict()
    v = self.y
    if type(v) != Float: v = Float(v)
    _d["y"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Coordinate2D, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Coordinate2D, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Coordinate2D, target, self, deepcopy),
     name="Coordinate2D=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Coordinate2D) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.x != _a.x: return False
    if self.y != _a.y: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    x = self.x
    y = self.y
    x.default = 0
    y.default = 0    
    x.digits = 3
    y.digits = 3
spyder.__types__["Coordinate2D"] = Coordinate2D
spyder.core.error["Coordinate2D"] = {}
if hasattr(Coordinate2D, '_register_errors'): Coordinate2D._register_errors()
Coordinate2D._requiredmembers = [['Float', 'x', 1], ['Float', 'y', 2]]
Coordinate2D._defaultmembers = []
Coordinate2D.__form__()
ResourceCoordinate2D = spyder.__types__["_Resource"](Coordinate2D)

Coordinate2D.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Coordinate2D,
  "constructor_fromany",
)
Coordinate2D.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Coordinate2D,
  "constructor_fromany",
)
Coordinate2D.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Coordinate2D,
  "constructor_fromany",
)

class Coordinate2DArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Coordinate2DArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Coordinate2DArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Coordinate2DArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Coordinate2DArray, target, self,deepcopy),
     name="Coordinate2DArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Coordinate2DArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Coordinate2D: self[vnr] = Coordinate2D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Coordinate2DArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Coordinate2DArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Coordinate2D,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Coordinate2DArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Coordinate2DArray.__dict__[Coordinate2DArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Coordinate2D, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Coordinate2DArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Coordinate2DArray","Coordinate2D","SPLIT")
spyder.core.defineconverter("Coordinate2D","Coordinate2DArray","CAST")
spyder.__types__["Coordinate2DArray"] = globals()["Coordinate2DArray"]  
arrayclass = spyder.__types__["Coordinate2DArray"]
spyder.__types__["ResourceCoordinate2DArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Coordinate2DArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Coordinate2DArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Coordinate2DArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Coordinate2DArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Coordinate2DArrayArray, target, self,deepcopy),
     name="Coordinate2DArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Coordinate2DArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Coordinate2D: self[vnr] = Coordinate2D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Coordinate2DArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Coordinate2DArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Coordinate2DArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Coordinate2DArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Coordinate2DArrayArray.__dict__[Coordinate2DArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Coordinate2DArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Coordinate2DArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Coordinate2DArrayArray","Coordinate2DArray","SPLIT")
spyder.core.defineconverter("Coordinate2DArray","Coordinate2DArrayArray","CAST")
spyder.__types__["Coordinate2DArrayArray"] = globals()["Coordinate2DArrayArray"]  
arrayclass = spyder.__types__["Coordinate2DArrayArray"]
spyder.__types__["ResourceCoordinate2DArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class GridCoordinate2D(Object):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type GridCoordinate2D {
  Integer x
  Integer y
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "GridCoordinate2D"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a GridCoordinate2D object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a GridCoordinate2D object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    GridCoordinate2D.__dict__[GridCoordinate2D.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a GridCoordinate2D object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (GridCoordinate2D) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (GridCoordinate2D) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (GridCoordinate2D) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (GridCoordinate2D) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("GridCoordinate2D") and args[0][len("GridCoordinate2D"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (GridCoordinate2D) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (GridCoordinate2D) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (GridCoordinate2D) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, x,y):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.x = reconstruct(self, Integer,"x",x)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.y = reconstruct(self, Integer,"y",y)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("x","y")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,x,y,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return x,y
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a.x
    except AttributeError:
      _missing_members.append('x')
    try:
      y = _a.y
    except AttributeError:
      _missing_members.append('y')
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (x,y,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a['x']
    except KeyError:
      _missing_members.append('x')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      y = _a['y']
    except KeyError:
      _missing_members.append('y')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (x,y,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.x = Integer(self.x)
      self.y = Integer(self.y)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.x
    if type(v) != Integer: v = Integer(v)
    ret += "%sx = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.y
    if type(v) != Integer: v = Integer(v)
    ret += "%sy = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.x
    if type(v) != Integer: v = Integer(v)
    _d["x"] = v.dict()
    v = self.y
    if type(v) != Integer: v = Integer(v)
    _d["y"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(GridCoordinate2D, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(GridCoordinate2D, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (GridCoordinate2D, target, self, deepcopy),
     name="GridCoordinate2D=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,GridCoordinate2D) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.x != _a.x: return False
    if self.y != _a.y: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["GridCoordinate2D"] = GridCoordinate2D
spyder.core.error["GridCoordinate2D"] = {}
if hasattr(GridCoordinate2D, '_register_errors'): GridCoordinate2D._register_errors()
GridCoordinate2D._requiredmembers = [['Integer', 'x', 1], ['Integer', 'y', 2]]
GridCoordinate2D._defaultmembers = []
GridCoordinate2D.__form__()
ResourceGridCoordinate2D = spyder.__types__["_Resource"](GridCoordinate2D)

GridCoordinate2D.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  GridCoordinate2D,
  "constructor_fromany",
)
GridCoordinate2D.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  GridCoordinate2D,
  "constructor_fromany",
)
GridCoordinate2D.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  GridCoordinate2D,
  "constructor_fromany",
)

class GridCoordinate2DArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "GridCoordinate2DArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, GridCoordinate2DArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(GridCoordinate2DArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (GridCoordinate2DArray, target, self,deepcopy),
     name="GridCoordinate2DArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(GridCoordinate2DArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != GridCoordinate2D: self[vnr] = GridCoordinate2D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((GridCoordinate2DArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((GridCoordinate2DArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(GridCoordinate2D,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a GridCoordinate2DArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    GridCoordinate2DArray.__dict__[GridCoordinate2DArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.GridCoordinate2D, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a GridCoordinate2DArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("GridCoordinate2DArray","GridCoordinate2D","SPLIT")
spyder.core.defineconverter("GridCoordinate2D","GridCoordinate2DArray","CAST")
spyder.__types__["GridCoordinate2DArray"] = globals()["GridCoordinate2DArray"]  
arrayclass = spyder.__types__["GridCoordinate2DArray"]
spyder.__types__["ResourceGridCoordinate2DArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class GridCoordinate2DArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "GridCoordinate2DArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, GridCoordinate2DArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(GridCoordinate2DArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (GridCoordinate2DArrayArray, target, self,deepcopy),
     name="GridCoordinate2DArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(GridCoordinate2DArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != GridCoordinate2D: self[vnr] = GridCoordinate2D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((GridCoordinate2DArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((GridCoordinate2DArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(GridCoordinate2DArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a GridCoordinate2DArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    GridCoordinate2DArrayArray.__dict__[GridCoordinate2DArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.GridCoordinate2DArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a GridCoordinate2DArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("GridCoordinate2DArrayArray","GridCoordinate2DArray","SPLIT")
spyder.core.defineconverter("GridCoordinate2DArray","GridCoordinate2DArrayArray","CAST")
spyder.__types__["GridCoordinate2DArrayArray"] = globals()["GridCoordinate2DArrayArray"]  
arrayclass = spyder.__types__["GridCoordinate2DArrayArray"]
spyder.__types__["ResourceGridCoordinate2DArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Coordinate(ThreeDee):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

Class for 3D (x,y,z) coordinates. 
    Coordinates are interpreted as x = right, y = up, z = towards the viewer
  
----------------------------------------------------------------------
Spyder definition:

Type Coordinate(ThreeDee) {
  #!#!#!
  Class for 3D (x,y,z) coordinates. 
    Coordinates are interpreted as x = right, y = up, z = towards the viewer
  #!#!#!
  Float x
  Float y
  Float z
  form {
    x.default = 0
    y.default = 0    
    z.default = 0    
    x.digits = 3
    y.digits = 3
    z.digits = 3
  }  
  def __mul__(self, a): 
  def __rmul__(self, a):  
  def __truediv__(self, a):
  def __div__(self, a):
  def __rtruediv__(self, a):
  def __rdiv__(self, a):
  def size(self):
  def normalize(self):
  def crossproduct(self, v):
  def __xor__(self,v): ## ^, cross product
  def __neg__(self):
  def __add__(self, a):
  def __iadd__(self,a):
  def __sub__(self,a):
  def __isub__(self,a):
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Coordinate"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Coordinate object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Coordinate object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Coordinate.__dict__[Coordinate.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Coordinate object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Coordinate) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Coordinate) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Coordinate) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Coordinate) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Coordinate") and args[0][len("Coordinate"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Coordinate) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Coordinate) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Coordinate) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, x,y,z):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.x = reconstruct(self, Float,"x",x)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.y = reconstruct(self, Float,"y",y)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.z = reconstruct(self, Float,"z",z)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("x","y","z")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,x,y,z,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return x,y,z
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a.x
    except AttributeError:
      _missing_members.append('x')
    try:
      y = _a.y
    except AttributeError:
      _missing_members.append('y')
    try:
      z = _a.z
    except AttributeError:
      _missing_members.append('z')
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (x,y,z,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a['x']
    except KeyError:
      _missing_members.append('x')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      y = _a['y']
    except KeyError:
      _missing_members.append('y')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      z = _a['z']
    except KeyError:
      _missing_members.append('z')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (x,y,z,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.x = Float(self.x)
      self.y = Float(self.y)
      self.z = Float(self.z)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.x
    if type(v) != Float: v = Float(v)
    ret += "%sx = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.y
    if type(v) != Float: v = Float(v)
    ret += "%sy = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.z
    if type(v) != Float: v = Float(v)
    ret += "%sz = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.x
    if type(v) != Float: v = Float(v)
    _d["x"] = v.dict()
    v = self.y
    if type(v) != Float: v = Float(v)
    _d["y"] = v.dict()
    v = self.z
    if type(v) != Float: v = Float(v)
    _d["z"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Coordinate, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Coordinate, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Coordinate, target, self, deepcopy),
     name="Coordinate=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Coordinate) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.x != _a.x: return False
    if self.y != _a.y: return False
    if self.z != _a.z: return False
    try:
      if not ThreeDee.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    x = self.x
    y = self.y
    z = self.z
    x.default = 0
    y.default = 0    
    z.default = 0    
    x.digits = 3
    y.digits = 3
    z.digits = 3
  def __mul__(self, a): 
    """Multiplication with either:
      a Float (scaling)
      a Coordinate (dot product) 
      or an AxisSystem (vector-matrix multiplication)
    """
    types = (Float, Coordinate, AxisSystem)
    for t in types:  
      try:
        a = t(a)
      except:
        continue
      break
    else:
      raise TypeError("Unknown type")
    if t == Float: #scale
      return Coordinate(a*self.x,a*self.y, a*self.z)
    elif t == Coordinate: #dot product
      return a.x*self.x+a.y*self.y+a.z*self.z
    elif t == AxisSystem: #vector-matrix multiplication
      ret = Coordinate(a.origin)
      ret += self.x * a.x
      ret += self.y * a.y
      ret += self.z * a.z
      return ret
  def __rmul__(self, a):  
    """Inline multiplication"""
    return self * a
  def __truediv__(self, a):
    """Division by Float: equivalent to 1/a multiplication"""
    a = Float(a)
    return self * (1/a)
  def __div__(self, a):
    """Division by Float: equivalent to 1/a multiplication"""
    a = Float(a)
    return self * (1/a)
  def __rtruediv__(self, a):
    """Inline division by Float"""
    a = Float(a)
    return self * (1/a)
  def __rdiv__(self, a):
    """Inline division by Float"""
    a = Float(a)
    return self * (1/a)
  def size(self):
    """The scalar length of the Coordinate"""
    return sqrt(self.x**2+self.y**2+self.z**2)
  def normalize(self):
    """Re-scale the Coordinate length to 1 
    , returns Vector"""
    v = Coordinate(self)
    size = v.size()
    if size > 0: v /= size
    else: v = (1,0,0)
    return Vector(v)    
  def crossproduct(self, v):
    """Returns a Coordinate perpendicular both to this one and to v"""
    v = Coordinate(v)
    x = self.y * v.z - self.z * v.y
    y = self.z * v.x - self.x * v.z
    z = self.x * v.y - self.y * v.x
    return Coordinate(x,y,z).normalize()
  def __xor__(self,v): ## ^, cross product
    """Symbol ^, equivalent to crossproduct"""
    return self.crossproduct(v)
  def __neg__(self):
    """Negation, returns -self"""
    return type(self)(-self.x,-self.y,-self.z)
  def __add__(self, a):
    """Addition of another Coordinate"""
    a = Coordinate(a)
    return Coordinate(self.x+a.x, self.y+a.y, self.z+a.z)
  def __iadd__(self,a):
    """Inline addition"""
    self = type(self)(self + a)
    return self
  def __sub__(self,a):
    """Subtraction of another Coordinate"""
    return self + -a
  def __isub__(self,a):
    """Inline subtraction"""
    self = type(self)(self - a)
    return self
spyder.__types__["Coordinate"] = Coordinate
spyder.core.error["Coordinate"] = {}
if hasattr(Coordinate, '_register_errors'): Coordinate._register_errors()
Coordinate._requiredmembers = [['Float', 'x', 1], ['Float', 'y', 2], ['Float', 'z', 3]]
Coordinate._defaultmembers = []
Coordinate.__form__()
ResourceCoordinate = spyder.__types__["_Resource"](Coordinate)

Coordinate.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Coordinate,
  "constructor_fromany",
)
Coordinate.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Coordinate,
  "constructor_fromany",
)
Coordinate.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Coordinate,
  "constructor_fromany",
)

class CoordinateArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "CoordinateArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, CoordinateArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(CoordinateArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (CoordinateArray, target, self,deepcopy),
     name="CoordinateArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(CoordinateArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Coordinate: self[vnr] = Coordinate(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((CoordinateArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((CoordinateArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Coordinate,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a CoordinateArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    CoordinateArray.__dict__[CoordinateArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Coordinate, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a CoordinateArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("CoordinateArray","Coordinate","SPLIT")
spyder.core.defineconverter("Coordinate","CoordinateArray","CAST")
spyder.__types__["CoordinateArray"] = globals()["CoordinateArray"]  
arrayclass = spyder.__types__["CoordinateArray"]
spyder.__types__["ResourceCoordinateArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class CoordinateArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "CoordinateArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, CoordinateArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(CoordinateArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (CoordinateArrayArray, target, self,deepcopy),
     name="CoordinateArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(CoordinateArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Coordinate: self[vnr] = Coordinate(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((CoordinateArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((CoordinateArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(CoordinateArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a CoordinateArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    CoordinateArrayArray.__dict__[CoordinateArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.CoordinateArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a CoordinateArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("CoordinateArrayArray","CoordinateArray","SPLIT")
spyder.core.defineconverter("CoordinateArray","CoordinateArrayArray","CAST")
spyder.__types__["CoordinateArrayArray"] = globals()["CoordinateArrayArray"]  
arrayclass = spyder.__types__["CoordinateArrayArray"]
spyder.__types__["ResourceCoordinateArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Vector(Coordinate):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

Fork of Coordinate that ensures a length of 1
----------------------------------------------------------------------
Spyder definition:

Type Vector(Coordinate) {
  #!#!#!
  Fork of Coordinate that ensures a length of 1
  #!#!#!
  Delete form
  form {
    x.min = -1
    x.max = 1
    x.default = 0
    y.min = -1
    y.max = 1
    y.default = 0    
    z.min = -1
    z.max = 1
    z.default = 0        
  }    
  validate {
    assert abs(x**2+y**2+z**2 - 1) < 0.001
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Vector"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Vector object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Vector object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Vector.__dict__[Vector.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Vector object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Vector) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Vector) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Vector) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Vector) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Vector") and args[0][len("Vector"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Vector) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Vector) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Vector) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, x,y,z):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.x = reconstruct(self, Float,"x",x)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.y = reconstruct(self, Float,"y",y)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.z = reconstruct(self, Float,"z",z)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("x","y","z")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,x,y,z,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return x,y,z
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a.x
    except AttributeError:
      _missing_members.append('x')
    try:
      y = _a.y
    except AttributeError:
      _missing_members.append('y')
    try:
      z = _a.z
    except AttributeError:
      _missing_members.append('z')
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (x,y,z,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a['x']
    except KeyError:
      _missing_members.append('x')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      y = _a['y']
    except KeyError:
      _missing_members.append('y')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      z = _a['z']
    except KeyError:
      _missing_members.append('z')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (x,y,z,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.x = Float(self.x)
      self.y = Float(self.y)
      self.z = Float(self.z)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    x = self.x
    y = self.y
    z = self.z
    spyder.core._assert(self, 'abs(x**2+y**2+z**2 - 1) < 0.001', 'assert abs(x**2+y**2+z**2 - 1) < 0.001')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'assert abs(x**2+y**2+z**2 - 1) < 0.001', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.x
    if type(v) != Float: v = Float(v)
    ret += "%sx = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.y
    if type(v) != Float: v = Float(v)
    ret += "%sy = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.z
    if type(v) != Float: v = Float(v)
    ret += "%sz = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.x
    if type(v) != Float: v = Float(v)
    _d["x"] = v.dict()
    v = self.y
    if type(v) != Float: v = Float(v)
    _d["y"] = v.dict()
    v = self.z
    if type(v) != Float: v = Float(v)
    _d["z"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Vector, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Vector, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Vector, target, self, deepcopy),
     name="Vector=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Vector) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.x != _a.x: return False
    if self.y != _a.y: return False
    if self.z != _a.z: return False
    try:
      if not Coordinate.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    x = self.x
    y = self.y
    z = self.z
    x.min = -1
    x.max = 1
    x.default = 0
    y.min = -1
    y.max = 1
    y.default = 0    
    z.min = -1
    z.max = 1
    z.default = 0        
  def __mul__(self, a): 
    """Multiplication with either:
      a Float (scaling)
      a Coordinate (dot product) 
      or an AxisSystem (vector-matrix multiplication)
    """
    types = (Float, Coordinate, AxisSystem)
    for t in types:  
      try:
        a = t(a)
      except:
        continue
      break
    else:
      raise TypeError("Unknown type")
    if t == Float: #scale
      return Coordinate(a*self.x,a*self.y, a*self.z)
    elif t == Coordinate: #dot product
      return a.x*self.x+a.y*self.y+a.z*self.z
    elif t == AxisSystem: #vector-matrix multiplication
      ret = Coordinate(a.origin)
      ret += self.x * a.x
      ret += self.y * a.y
      ret += self.z * a.z
      return ret
  def __rmul__(self, a):  
    """Inline multiplication"""
    return self * a
  def __truediv__(self, a):
    """Division by Float: equivalent to 1/a multiplication"""
    a = Float(a)
    return self * (1/a)
  def __div__(self, a):
    """Division by Float: equivalent to 1/a multiplication"""
    a = Float(a)
    return self * (1/a)
  def __rtruediv__(self, a):
    """Inline division by Float"""
    a = Float(a)
    return self * (1/a)
  def __rdiv__(self, a):
    """Inline division by Float"""
    a = Float(a)
    return self * (1/a)
  def size(self):
    """The scalar length of the Coordinate"""
    return sqrt(self.x**2+self.y**2+self.z**2)
  def normalize(self):
    """Re-scale the Coordinate length to 1 
    , returns Vector"""
    v = Coordinate(self)
    size = v.size()
    if size > 0: v /= size
    else: v = (1,0,0)
    return Vector(v)    
  def crossproduct(self, v):
    """Returns a Coordinate perpendicular both to this one and to v"""
    v = Coordinate(v)
    x = self.y * v.z - self.z * v.y
    y = self.z * v.x - self.x * v.z
    z = self.x * v.y - self.y * v.x
    return Coordinate(x,y,z).normalize()
  def __xor__(self,v): ## ^, cross product
    """Symbol ^, equivalent to crossproduct"""
    return self.crossproduct(v)
  def __neg__(self):
    """Negation, returns -self"""
    return type(self)(-self.x,-self.y,-self.z)
  def __add__(self, a):
    """Addition of another Coordinate"""
    a = Coordinate(a)
    return Coordinate(self.x+a.x, self.y+a.y, self.z+a.z)
  def __iadd__(self,a):
    """Inline addition"""
    self = type(self)(self + a)
    return self
  def __sub__(self,a):
    """Subtraction of another Coordinate"""
    return self + -a
  def __isub__(self,a):
    """Inline subtraction"""
    self = type(self)(self - a)
    return self
spyder.__types__["Vector"] = Vector
spyder.core.error["Vector"] = {}
if hasattr(Vector, '_register_errors'): Vector._register_errors()
Vector._requiredmembers = [['Float', 'x', 1], ['Float', 'y', 2], ['Float', 'z', 3]]
Vector._defaultmembers = []
Vector.__form__()
ResourceVector = spyder.__types__["_Resource"](Vector)

Vector.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Vector,
  "constructor_fromany",
)
Vector.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Vector,
  "constructor_fromany",
)
Vector.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Vector,
  "constructor_fromany",
)

class VectorArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "VectorArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, VectorArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(VectorArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (VectorArray, target, self,deepcopy),
     name="VectorArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(VectorArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Vector: self[vnr] = Vector(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((VectorArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((VectorArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Vector,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a VectorArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    VectorArray.__dict__[VectorArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Vector, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a VectorArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("VectorArray","Vector","SPLIT")
spyder.core.defineconverter("Vector","VectorArray","CAST")
spyder.__types__["VectorArray"] = globals()["VectorArray"]  
arrayclass = spyder.__types__["VectorArray"]
spyder.__types__["ResourceVectorArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class VectorArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "VectorArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, VectorArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(VectorArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (VectorArrayArray, target, self,deepcopy),
     name="VectorArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(VectorArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Vector: self[vnr] = Vector(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((VectorArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((VectorArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(VectorArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a VectorArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    VectorArrayArray.__dict__[VectorArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.VectorArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a VectorArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("VectorArrayArray","VectorArray","SPLIT")
spyder.core.defineconverter("VectorArray","VectorArrayArray","CAST")
spyder.__types__["VectorArrayArray"] = globals()["VectorArrayArray"]  
arrayclass = spyder.__types__["VectorArrayArray"]
spyder.__types__["ResourceVectorArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()

"""Define Vector(Coordinate) Coordinate.normalize"""
spyder.core.defineconverter("Coordinate","Vector",Coordinate.normalize)

class AxisSystem(ThreeDee):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

Implementation of a coordinate system
   consisting of an origin and x,y and z axes
  
----------------------------------------------------------------------
Spyder definition:

Type AxisSystem(ThreeDee) {
  #!#!#!
  Implementation of a coordinate system
   consisting of an origin and x,y and z axes
  #!#!#!
  Coordinate origin = (0,0,0)
  Coordinate x = (1,0,0)
  Coordinate y = (0,1,0)
  Coordinate z = (0,0,1)
  def __mul__(self,a):
  def rotateAxis(self, axis ,ang, full=False):  
  def rotateX(self,ang): 
  def rotateY(self,ang): 
  def rotateZ(self,ang): 
  def rotateXFull(self,ang): 
  def rotateYFull(self,ang): 
  def rotateZFull(self,ang): 
  def rotateLocalX(self,ang): 
  def rotateLocalY(self,ang): 
  def rotateLocalZ(self,ang): 
  def rotateLocalXFull(self,ang): 
  def rotateLocalYFull(self,ang): 
  def rotateLocalZFull(self,ang): 
  form {
    self.subtype = "column"
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "AxisSystem"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a AxisSystem object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a AxisSystem object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    AxisSystem.__dict__[AxisSystem.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a AxisSystem object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (AxisSystem) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (AxisSystem) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (AxisSystem) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (AxisSystem) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("AxisSystem") and args[0][len("AxisSystem"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (AxisSystem) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (AxisSystem) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (AxisSystem) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, origin,x,y,z):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if origin is default0 or (origin.__class__ is default0.__class__ and origin == default0):      reconstruct_func = reconstruct_default
    try:
      self.origin = reconstruct_func(self, Coordinate,"origin",origin)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if x is default0 or (x.__class__ is default0.__class__ and x == default0):      reconstruct_func = reconstruct_default
    try:
      self.x = reconstruct_func(self, Coordinate,"x",x)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[2] if spyder.python3 else self.__unpack2__.func_defaults[2]
    if y is default0 or (y.__class__ is default0.__class__ and y == default0):      reconstruct_func = reconstruct_default
    try:
      self.y = reconstruct_func(self, Coordinate,"y",y)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[3] if spyder.python3 else self.__unpack2__.func_defaults[3]
    if z is default0 or (z.__class__ is default0.__class__ and z == default0):      reconstruct_func = reconstruct_default
    try:
      self.z = reconstruct_func(self, Coordinate,"z",z)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ()
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,origin=(0,0,0),x=(1,0,0),y=(0,1,0),z=(0,0,1),*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return origin,x,y,z
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    ok = (_a == None or isinstance(_a,AxisSystem))
    origin = (0,0,0)
    if hasattr(_a,"origin") and _a.origin != None:
      ok = True
      origin = _a.origin
    x = (1,0,0)
    if hasattr(_a,"x") and _a.x != None:
      ok = True
      x = _a.x
    y = (0,1,0)
    if hasattr(_a,"y") and _a.y != None:
      ok = True
      y = _a.y
    z = (0,0,1)
    if hasattr(_a,"z") and _a.z != None:
      ok = True
      z = _a.z
    if ok == False: raise spyder.ConstructionError("Object '%s' has no matching attributes" % type(_a).__name__ )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (origin,x,y,z,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    ok = (_a == None or isinstance(_a, dict))
    origin = (0,0,0)
    if "origin" in _a:
      ok = True
      origin = _a["origin"]
    if isinstance(_a, dict) and "origin" in _a: origin = _a["origin"]
    x = (1,0,0)
    if "x" in _a:
      ok = True
      x = _a["x"]
    if isinstance(_a, dict) and "x" in _a: x = _a["x"]
    y = (0,1,0)
    if "y" in _a:
      ok = True
      y = _a["y"]
    if isinstance(_a, dict) and "y" in _a: y = _a["y"]
    z = (0,0,1)
    if "z" in _a:
      ok = True
      z = _a["z"]
    if isinstance(_a, dict) and "z" in _a: z = _a["z"]
    if ok == False: raise AttributeError
    return (origin,x,y,z,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.origin = Coordinate(self.origin)
      self.x = Coordinate(self.x)
      self.y = Coordinate(self.y)
      self.z = Coordinate(self.z)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    ret += "%sorigin = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.x
    if type(v) != Coordinate: v = Coordinate(v)
    ret += "%sx = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.y
    if type(v) != Coordinate: v = Coordinate(v)
    ret += "%sy = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.z
    if type(v) != Coordinate: v = Coordinate(v)
    ret += "%sz = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    _d["origin"] = v.dict()
    v = self.x
    if type(v) != Coordinate: v = Coordinate(v)
    _d["x"] = v.dict()
    v = self.y
    if type(v) != Coordinate: v = Coordinate(v)
    _d["y"] = v.dict()
    v = self.z
    if type(v) != Coordinate: v = Coordinate(v)
    _d["z"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(AxisSystem, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(AxisSystem, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (AxisSystem, target, self, deepcopy),
     name="AxisSystem=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,AxisSystem) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.origin != _a.origin: return False
    if self.x != _a.x: return False
    if self.y != _a.y: return False
    if self.z != _a.z: return False
    try:
      if not ThreeDee.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    origin = self.origin
    x = self.x
    y = self.y
    z = self.z
    self.subtype = "column"
  def __mul__(self,a):
    """Multiplication with either:
     a Float (scaling)
     a Coordinate (vector-matrix multiplication)
     or an AxisSystem (matrix-matrix multiplication)
    """ 
    types = (Float, Coordinate, AxisSystem)
    for t in types:  
      try:
        a = t(a)
      except:
        continue
      break
    else:
      raise TypeError("Unknown type")
    if t == Float:
      ret = AxisSystem(self.origin, self.x*a, self.y*a, self.z*a)
      return ret
    if t == Coordinate:
      return t * self
    if t == AxisSystem:
      ret = AxisSystem()
      b = self
      ret.x = a.x * b.x.x + a.y * b.x.y + a.z * b.x.z 
      ret.y = a.x * b.y.x + a.y * b.y.y + a.z * b.y.z
      ret.z = a.x * b.z.x + a.y * b.z.y + a.z * b.z.z
      ret.origin = a.x * b.origin.x + a.y * b.origin.y + a.z * b.origin.z + a.origin
      return ret
  def rotateAxis(self, axis ,ang, full=False):  
    """Rotate around an arbitrary axis by an angle in degrees
    if full == True, rotate the axis origin as well """
    a = Coordinate(axis).normalize()
    x, y, z = a.x, a.y, a.z
    radang = ang/180.0 * pi
    c = cos(radang)
    s = sin(radang)
    t = 1 - c
    v1,v2,v3 = (Vector(t*x*x+c, t*x*y-s*z, t*x*z+s*y),
               Vector(t*y*x+s*z, t*y*y+c, t*y*z-s*x),
               Vector(t*x*z-s*y, t*y*z+s*x, t*z*z+c))
    mat = AxisSystem((0,0,0),v1,v2,v3)
    ret = self * mat
    self.x,self.y,self.z = ret.x,ret.y,ret.z
    if full:
      self.origin = self.origin * mat    
    return self
  def rotateX(self,ang): 
    """Rotate around the global X axis by an angle in degrees"""
    return self.rotateAxis((1,0,0),ang)
  def rotateY(self,ang): 
    """Rotate around the global Y axis by an angle in degrees"""
    return self.rotateAxis((0,1,0),ang)
  def rotateZ(self,ang): 
    """Rotate around the global Z axis by an angle in degrees"""
    return self.rotateAxis((0,0,1),ang)
  def rotateXFull(self,ang): 
    """Rotate around the global X axis by an angle in degrees
     and rotate the axis origin as well"""
    return self.rotateAxis((1,0,0),ang,True)
  def rotateYFull(self,ang): 
    """Rotate around the global Y axis by an angle in degrees
     and rotate the axis origin as well"""
    return self.rotateAxis((0,1,0),ang,True)
  def rotateZFull(self,ang): 
    """Rotate around the global Z axis by an angle in degrees
     and rotate the axis origin as well"""
    return self.rotateAxis((0,0,1),ang,True)
  def rotateLocalX(self,ang): 
    """Rotate around the local X axis by an angle in degrees"""
    return self.rotateAxis(self.x,ang)
  def rotateLocalY(self,ang): 
    """Rotate around the local Y axis by an angle in degrees"""
    return self.rotateAxis(self.y,ang)
  def rotateLocalZ(self,ang): 
    """Rotate around the local Z axis by an angle in degrees"""
    return self.rotateAxis(self.z,ang)
  def rotateLocalXFull(self,ang): 
    """Rotate around the local X axis by an angle in degrees
     and rotate the axis origin as well"""
    return self.rotateAxis(self.x,ang,True)
  def rotateLocalYFull(self,ang): 
    """Rotate around the local Y axis by an angle in degrees
     and rotate the axis origin as well"""
    return self.rotateAxis(self.y,ang,True)
  def rotateLocalZFull(self,ang): 
    """Rotate around the local Z axis by an angle in degrees
     and rotate the axis origin as well"""
    return self.rotateAxis(self.z,ang,True)
spyder.__types__["AxisSystem"] = AxisSystem
spyder.core.error["AxisSystem"] = {}
if hasattr(AxisSystem, '_register_errors'): AxisSystem._register_errors()
AxisSystem._requiredmembers = []
AxisSystem._defaultmembers = [['Coordinate', 'origin', '(0,0,0)', 1], ['Coordinate', 'x', '(1,0,0)', 2], ['Coordinate', 'y', '(0,1,0)', 3], ['Coordinate', 'z', '(0,0,1)', 4]]
AxisSystem.__form__()
ResourceAxisSystem = spyder.__types__["_Resource"](AxisSystem)

AxisSystem.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  AxisSystem,
  "constructor_fromany",
)
AxisSystem.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  AxisSystem,
  "constructor_fromany",
)
AxisSystem.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  AxisSystem,
  "constructor_fromany",
)

class AxisSystemArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "AxisSystemArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, AxisSystemArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(AxisSystemArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (AxisSystemArray, target, self,deepcopy),
     name="AxisSystemArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(AxisSystemArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != AxisSystem: self[vnr] = AxisSystem(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((AxisSystemArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((AxisSystemArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(AxisSystem,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a AxisSystemArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    AxisSystemArray.__dict__[AxisSystemArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.AxisSystem, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a AxisSystemArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("AxisSystemArray","AxisSystem","SPLIT")
spyder.core.defineconverter("AxisSystem","AxisSystemArray","CAST")
spyder.__types__["AxisSystemArray"] = globals()["AxisSystemArray"]  
arrayclass = spyder.__types__["AxisSystemArray"]
spyder.__types__["ResourceAxisSystemArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class AxisSystemArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "AxisSystemArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, AxisSystemArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(AxisSystemArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (AxisSystemArrayArray, target, self,deepcopy),
     name="AxisSystemArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(AxisSystemArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != AxisSystem: self[vnr] = AxisSystem(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((AxisSystemArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((AxisSystemArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(AxisSystemArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a AxisSystemArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    AxisSystemArrayArray.__dict__[AxisSystemArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.AxisSystemArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a AxisSystemArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("AxisSystemArrayArray","AxisSystemArray","SPLIT")
spyder.core.defineconverter("AxisSystemArray","AxisSystemArrayArray","CAST")
spyder.__types__["AxisSystemArrayArray"] = globals()["AxisSystemArrayArray"]  
arrayclass = spyder.__types__["AxisSystemArrayArray"]
spyder.__types__["ResourceAxisSystemArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()

"""Method matrix(AxisSystem) axissystem_to_matrix \"\"\"Generate a C double[16] object that contains the axis system in 4x4 matrix form\"\"\"
"""
spyder.core.definemethod("matrix","AxisSystem",axissystem_to_matrix)

class Edge3D(Object):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

Edge class, should be part of a class that defines vertices
  Consists of two vertex indices and a crease parameter
  A higher crease parameter indicates edge sharpness
  
----------------------------------------------------------------------
Spyder definition:

Type Edge3D {
  #!#!#!
  Edge class, should be part of a class that defines vertices
  Consists of two vertex indices and a crease parameter
  A higher crease parameter indicates edge sharpness
  #!#!#!
  Integer v1
  Integer v2
  Integer crease = 0
  validate {
    assert crease >= 0 and crease < 256
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Edge3D"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Edge3D object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Edge3D object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Edge3D.__dict__[Edge3D.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Edge3D object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Edge3D) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Edge3D) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Edge3D) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Edge3D) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Edge3D") and args[0][len("Edge3D"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Edge3D) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Edge3D) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Edge3D) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, v1,v2,crease):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.v1 = reconstruct(self, Integer,"v1",v1)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.v2 = reconstruct(self, Integer,"v2",v2)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if crease is default0 or (crease.__class__ is default0.__class__ and crease == default0):      reconstruct_func = reconstruct_default
    try:
      self.crease = reconstruct_func(self, Integer,"crease",crease)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("v1","v2")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,v1,v2,crease=0,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return v1,v2,crease
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      v1 = _a.v1
    except AttributeError:
      _missing_members.append('v1')
    try:
      v2 = _a.v2
    except AttributeError:
      _missing_members.append('v2')
    crease = 0
    if hasattr(_a,"crease") and _a.crease != None: crease = _a.crease
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (v1,v2,crease,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      v1 = _a['v1']
    except KeyError:
      _missing_members.append('v1')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      v2 = _a['v2']
    except KeyError:
      _missing_members.append('v2')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    crease = 0
    if "crease" in _a: crease = _a["crease"]
    if isinstance(_a, dict) and "crease" in _a: crease = _a["crease"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (v1,v2,crease,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.v1 = Integer(self.v1)
      self.v2 = Integer(self.v2)
      self.crease = Integer(self.crease)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    v1 = self.v1
    v2 = self.v2
    crease = self.crease
    spyder.core._assert(self, 'crease >= 0 and crease < 256', 'assert crease >= 0 and crease < 256')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'assert crease >= 0 and crease < 256', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.v1
    if type(v) != Integer: v = Integer(v)
    ret += "%sv1 = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.v2
    if type(v) != Integer: v = Integer(v)
    ret += "%sv2 = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.crease
    if type(v) != Integer: v = Integer(v)
    ret += "%screase = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.v1
    if type(v) != Integer: v = Integer(v)
    _d["v1"] = v.dict()
    v = self.v2
    if type(v) != Integer: v = Integer(v)
    _d["v2"] = v.dict()
    v = self.crease
    if type(v) != Integer: v = Integer(v)
    _d["crease"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Edge3D, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Edge3D, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Edge3D, target, self, deepcopy),
     name="Edge3D=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Edge3D) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.v1 != _a.v1: return False
    if self.v2 != _a.v2: return False
    if self.crease != _a.crease: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Edge3D"] = Edge3D
spyder.core.error["Edge3D"] = {}
if hasattr(Edge3D, '_register_errors'): Edge3D._register_errors()
Edge3D._requiredmembers = [['Integer', 'v1', 1], ['Integer', 'v2', 2]]
Edge3D._defaultmembers = [['Integer', 'crease', '0', 3]]
Edge3D.__form__()
ResourceEdge3D = spyder.__types__["_Resource"](Edge3D)

Edge3D.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Edge3D,
  "constructor_fromany",
)
Edge3D.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Edge3D,
  "constructor_fromany",
)
Edge3D.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Edge3D,
  "constructor_fromany",
)

class Edge3DArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Edge3DArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Edge3DArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Edge3DArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Edge3DArray, target, self,deepcopy),
     name="Edge3DArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Edge3DArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Edge3D: self[vnr] = Edge3D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Edge3DArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Edge3DArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Edge3D,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Edge3DArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Edge3DArray.__dict__[Edge3DArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Edge3D, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Edge3DArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Edge3DArray","Edge3D","SPLIT")
spyder.core.defineconverter("Edge3D","Edge3DArray","CAST")
spyder.__types__["Edge3DArray"] = globals()["Edge3DArray"]  
arrayclass = spyder.__types__["Edge3DArray"]
spyder.__types__["ResourceEdge3DArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Edge3DArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Edge3DArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Edge3DArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Edge3DArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Edge3DArrayArray, target, self,deepcopy),
     name="Edge3DArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Edge3DArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Edge3D: self[vnr] = Edge3D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Edge3DArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Edge3DArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Edge3DArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Edge3DArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Edge3DArrayArray.__dict__[Edge3DArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Edge3DArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Edge3DArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Edge3DArrayArray","Edge3DArray","SPLIT")
spyder.core.defineconverter("Edge3DArray","Edge3DArrayArray","CAST")
spyder.__types__["Edge3DArrayArray"] = globals()["Edge3DArrayArray"]  
arrayclass = spyder.__types__["Edge3DArrayArray"]
spyder.__types__["ResourceEdge3DArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Face3D(Object):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

Face class, should be part of a class that defines vertices and materials
  Material definition is optional; 
   if none is defined, the material of the parent class should be used
  Looking from the outside, vertices should be specified counter-clockwise
  If specified, the normal should point inward
  Normals for every vertex can be specified, too (for smooth lighting)
  Texture coordinates are not yet implemented in Tarantula
  
----------------------------------------------------------------------
Spyder definition:

Type Face3D {
  #!#!#!
  Face class, should be part of a class that defines vertices and materials
  Material definition is optional; 
   if none is defined, the material of the parent class should be used
  Looking from the outside, vertices should be specified counter-clockwise
  If specified, the normal should point inward
  Normals for every vertex can be specified, too (for smooth lighting)
  Texture coordinates are not yet implemented in Tarantula
  #!#!#!
  IntegerArray vertices
  *Material material
  *Coordinate2DArray texturecoords
  *Vector normal
  *VectorArray vertexnormals
  validate {
    assert texturecoords == None or len(texturecoords) == len(vertices)
    assert vertexnormals == None or len(vertexnormals) == len(vertices)
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Face3D"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Face3D object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Face3D object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Face3D.__dict__[Face3D.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Face3D object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Face3D) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Face3D) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Face3D) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Face3D) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Face3D") and args[0][len("Face3D"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Face3D) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Face3D) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Face3D) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, vertices,material,texturecoords,normal,vertexnormals):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.vertices = reconstruct(self, IntegerArray,"vertices",vertices)
    except Exception as exc:
      exc.__context__ = None; raise
    self.material = None
    try:
      if material is not None: self.material = reconstruct(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
    self.texturecoords = None
    try:
      if texturecoords is not None: self.texturecoords = reconstruct(self, Coordinate2DArray,"texturecoords",texturecoords)
    except Exception as exc:
      exc.__context__ = None; raise
    self.normal = None
    try:
      if normal is not None: self.normal = reconstruct(self, Vector,"normal",normal)
    except Exception as exc:
      exc.__context__ = None; raise
    self.vertexnormals = None
    try:
      if vertexnormals is not None: self.vertexnormals = reconstruct(self, VectorArray,"vertexnormals",vertexnormals)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("vertices",)
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,vertices,material=None,texturecoords=None,normal=None,vertexnormals=None,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return vertices,material,texturecoords,normal,vertexnormals
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      vertices = _a.vertices
    except AttributeError:
      _missing_members.append('vertices')
    material = None
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    texturecoords = None
    if hasattr(_a,"texturecoords") and _a.texturecoords != None: texturecoords = _a.texturecoords
    normal = None
    if hasattr(_a,"normal") and _a.normal != None: normal = _a.normal
    vertexnormals = None
    if hasattr(_a,"vertexnormals") and _a.vertexnormals != None: vertexnormals = _a.vertexnormals
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (vertices,material,texturecoords,normal,vertexnormals,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      vertices = _a['vertices']
    except KeyError:
      _missing_members.append('vertices')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    material = None
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    texturecoords = None
    if "texturecoords" in _a: texturecoords = _a["texturecoords"]
    if isinstance(_a, dict) and "texturecoords" in _a: texturecoords = _a["texturecoords"]
    normal = None
    if "normal" in _a: normal = _a["normal"]
    if isinstance(_a, dict) and "normal" in _a: normal = _a["normal"]
    vertexnormals = None
    if "vertexnormals" in _a: vertexnormals = _a["vertexnormals"]
    if isinstance(_a, dict) and "vertexnormals" in _a: vertexnormals = _a["vertexnormals"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (vertices,material,texturecoords,normal,vertexnormals,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.vertices = IntegerArray(self.vertices)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    vertices = self.vertices
    material = self.material
    texturecoords = self.texturecoords
    normal = self.normal
    vertexnormals = self.vertexnormals
    spyder.core._assert(self, 'texturecoords == None or len(texturecoords) == len(vertices)', 'assert texturecoords == None or len(texturecoords) == len(vertices)')
    spyder.core._assert(self, 'vertexnormals == None or len(vertexnormals) == len(vertices)', 'assert vertexnormals == None or len(vertexnormals) == len(vertices)')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'assert texturecoords == None or len(texturecoords) == len(vertices)', None)
    spyder.core._register_error(cls, 'assert vertexnormals == None or len(vertexnormals) == len(vertices)', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.vertices
    if type(v) != IntegerArray: v = IntegerArray(v)
    ret += "%svertices = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if v != None:
      if type(v) != Material: v = Material(v)
      ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.texturecoords
    if v != None:
      if type(v) != Coordinate2DArray: v = Coordinate2DArray(v)
      ret += "%stexturecoords = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.normal
    if v != None:
      if type(v) != Vector: v = Vector(v)
      ret += "%snormal = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.vertexnormals
    if v != None:
      if type(v) != VectorArray: v = VectorArray(v)
      ret += "%svertexnormals = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.vertices
    if type(v) != IntegerArray: v = IntegerArray(v)
    _d["vertices"] = v.dict()
    v = self.material
    if v != None:
      if type(v) != Material: v = Material(v)
      _d["material"] = v.dict()
    v = self.texturecoords
    if v != None:
      if type(v) != Coordinate2DArray: v = Coordinate2DArray(v)
      _d["texturecoords"] = v.dict()
    v = self.normal
    if v != None:
      if type(v) != Vector: v = Vector(v)
      _d["normal"] = v.dict()
    v = self.vertexnormals
    if v != None:
      if type(v) != VectorArray: v = VectorArray(v)
      _d["vertexnormals"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Face3D, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Face3D, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Face3D, target, self, deepcopy),
     name="Face3D=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Face3D) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.vertices != _a.vertices: return False
    if self.material != _a.material: return False
    if self.texturecoords != _a.texturecoords: return False
    if self.normal != _a.normal: return False
    if self.vertexnormals != _a.vertexnormals: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
if issubclass(IntegerArray,Spyder.String) or issubclass(IntegerArray,Spyder.Data):
  if not issubclass(Face3D,getattr(Spyder,"Degenerate")):
    raise TypeError("Spyder type 'Face3D' is degenerate: it has no more than one required member, and the first member can be constructed from a string.\nPlease change the members, or inherit explicitly from Spyder.Degenerate")
spyder.__types__["Face3D"] = Face3D
spyder.core.error["Face3D"] = {}
if hasattr(Face3D, '_register_errors'): Face3D._register_errors()
Face3D._requiredmembers = [['IntegerArray', 'vertices', 1]]
Face3D._defaultmembers = [['Material', 'material', 'None', 2], ['Coordinate2DArray', 'texturecoords', 'None', 3], ['Vector', 'normal', 'None', 4], ['VectorArray', 'vertexnormals', 'None', 5]]
Face3D.__form__()
ResourceFace3D = spyder.__types__["_Resource"](Face3D)

Face3D.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Face3D,
  "constructor_fromany",
)
Face3D.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Face3D,
  "constructor_fromany",
)
Face3D.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Face3D,
  "constructor_fromany",
)

class Face3DArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Face3DArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Face3DArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Face3DArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Face3DArray, target, self,deepcopy),
     name="Face3DArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Face3DArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Face3D: self[vnr] = Face3D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Face3DArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Face3DArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Face3D,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Face3DArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Face3DArray.__dict__[Face3DArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Face3D, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Face3DArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Face3DArray","Face3D","SPLIT")
spyder.core.defineconverter("Face3D","Face3DArray","CAST")
spyder.__types__["Face3DArray"] = globals()["Face3DArray"]  
arrayclass = spyder.__types__["Face3DArray"]
spyder.__types__["ResourceFace3DArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Face3DArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Face3DArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Face3DArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Face3DArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Face3DArrayArray, target, self,deepcopy),
     name="Face3DArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Face3DArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Face3D: self[vnr] = Face3D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Face3DArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Face3DArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Face3DArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Face3DArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Face3DArrayArray.__dict__[Face3DArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Face3DArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Face3DArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Face3DArrayArray","Face3DArray","SPLIT")
spyder.core.defineconverter("Face3DArray","Face3DArrayArray","CAST")
spyder.__types__["Face3DArrayArray"] = globals()["Face3DArrayArray"]  
arrayclass = spyder.__types__["Face3DArrayArray"]
spyder.__types__["ResourceFace3DArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Polygon(ThreeDee):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

Self-contained class for polygon data
  Looking from the outside, vertices should be specified counter-clockwise
  If specified, the normal should point inward
  Normals for every vertex can be specified, too (for smooth lighting)
  If a material other than "defaultmaterial" is used, 
   it must be elsewhere defined and show()'ed as a NewMaterial
  Texture coordinates are not yet implemented in Tarantula
  
----------------------------------------------------------------------
Spyder definition:

Type Polygon(ThreeDee) {
  #!#!#!
  Self-contained class for polygon data
  Looking from the outside, vertices should be specified counter-clockwise
  If specified, the normal should point inward
  Normals for every vertex can be specified, too (for smooth lighting)
  If a material other than "defaultmaterial" is used, 
   it must be elsewhere defined and show()'ed as a NewMaterial
  Texture coordinates are not yet implemented in Tarantula
  #!#!#!
  CoordinateArray vertices
  Material material = "defaultmaterial"
  AxisSystem axis = AxisSystem()
  *CoordinateArray texturecoords
  *Vector normal
  *VectorArray vertexnormals
  validate {
    assert texturecoords == None or len(texturecoords) == len(vertices)
    assert vertexnormals == None or len(vertexnormals) == len(vertices)
  }
  length {
    return len(vertices)
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Polygon"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Polygon object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Polygon object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Polygon.__dict__[Polygon.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Polygon object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Polygon) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Polygon) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Polygon) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Polygon) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Polygon") and args[0][len("Polygon"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Polygon) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Polygon) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Polygon) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, vertices,material,axis,texturecoords,normal,vertexnormals):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.vertices = reconstruct(self, CoordinateArray,"vertices",vertices)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if axis is default0 or (axis.__class__ is default0.__class__ and axis == default0):      reconstruct_func = reconstruct_default
    try:
      self.axis = reconstruct_func(self, AxisSystem,"axis",axis)
    except Exception as exc:
      exc.__context__ = None; raise
    self.texturecoords = None
    try:
      if texturecoords is not None: self.texturecoords = reconstruct(self, CoordinateArray,"texturecoords",texturecoords)
    except Exception as exc:
      exc.__context__ = None; raise
    self.normal = None
    try:
      if normal is not None: self.normal = reconstruct(self, Vector,"normal",normal)
    except Exception as exc:
      exc.__context__ = None; raise
    self.vertexnormals = None
    try:
      if vertexnormals is not None: self.vertexnormals = reconstruct(self, VectorArray,"vertexnormals",vertexnormals)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("vertices",)
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,vertices,material="defaultmaterial",axis=AxisSystem(),texturecoords=None,normal=None,vertexnormals=None,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return vertices,material,axis,texturecoords,normal,vertexnormals
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      vertices = _a.vertices
    except AttributeError:
      _missing_members.append('vertices')
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    axis = AxisSystem()
    if hasattr(_a,"axis") and _a.axis != None: axis = _a.axis
    texturecoords = None
    if hasattr(_a,"texturecoords") and _a.texturecoords != None: texturecoords = _a.texturecoords
    normal = None
    if hasattr(_a,"normal") and _a.normal != None: normal = _a.normal
    vertexnormals = None
    if hasattr(_a,"vertexnormals") and _a.vertexnormals != None: vertexnormals = _a.vertexnormals
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (vertices,material,axis,texturecoords,normal,vertexnormals,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      vertices = _a['vertices']
    except KeyError:
      _missing_members.append('vertices')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    axis = AxisSystem()
    if "axis" in _a: axis = _a["axis"]
    if isinstance(_a, dict) and "axis" in _a: axis = _a["axis"]
    texturecoords = None
    if "texturecoords" in _a: texturecoords = _a["texturecoords"]
    if isinstance(_a, dict) and "texturecoords" in _a: texturecoords = _a["texturecoords"]
    normal = None
    if "normal" in _a: normal = _a["normal"]
    if isinstance(_a, dict) and "normal" in _a: normal = _a["normal"]
    vertexnormals = None
    if "vertexnormals" in _a: vertexnormals = _a["vertexnormals"]
    if isinstance(_a, dict) and "vertexnormals" in _a: vertexnormals = _a["vertexnormals"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (vertices,material,axis,texturecoords,normal,vertexnormals,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.vertices = CoordinateArray(self.vertices)
      self.material = Material(self.material)
      self.axis = AxisSystem(self.axis)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    vertices = self.vertices
    material = self.material
    axis = self.axis
    texturecoords = self.texturecoords
    normal = self.normal
    vertexnormals = self.vertexnormals
    spyder.core._assert(self, 'texturecoords == None or len(texturecoords) == len(vertices)', 'assert texturecoords == None or len(texturecoords) == len(vertices)')
    spyder.core._assert(self, 'vertexnormals == None or len(vertexnormals) == len(vertices)', 'assert vertexnormals == None or len(vertexnormals) == len(vertices)')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'assert texturecoords == None or len(texturecoords) == len(vertices)', None)
    spyder.core._register_error(cls, 'assert vertexnormals == None or len(vertexnormals) == len(vertices)', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.vertices
    if type(v) != CoordinateArray: v = CoordinateArray(v)
    ret += "%svertices = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    ret += "%saxis = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.texturecoords
    if v != None:
      if type(v) != CoordinateArray: v = CoordinateArray(v)
      ret += "%stexturecoords = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.normal
    if v != None:
      if type(v) != Vector: v = Vector(v)
      ret += "%snormal = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.vertexnormals
    if v != None:
      if type(v) != VectorArray: v = VectorArray(v)
      ret += "%svertexnormals = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.vertices
    if type(v) != CoordinateArray: v = CoordinateArray(v)
    _d["vertices"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    _d["axis"] = v.dict()
    v = self.texturecoords
    if v != None:
      if type(v) != CoordinateArray: v = CoordinateArray(v)
      _d["texturecoords"] = v.dict()
    v = self.normal
    if v != None:
      if type(v) != Vector: v = Vector(v)
      _d["normal"] = v.dict()
    v = self.vertexnormals
    if v != None:
      if type(v) != VectorArray: v = VectorArray(v)
      _d["vertexnormals"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Polygon, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Polygon, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Polygon, target, self, deepcopy),
     name="Polygon=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Polygon) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.vertices != _a.vertices: return False
    if self.material != _a.material: return False
    if self.axis != _a.axis: return False
    if self.texturecoords != _a.texturecoords: return False
    if self.normal != _a.normal: return False
    if self.vertexnormals != _a.vertexnormals: return False
    try:
      if not ThreeDee.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
if issubclass(CoordinateArray,Spyder.String) or issubclass(CoordinateArray,Spyder.Data):
  if not issubclass(Polygon,getattr(Spyder,"Degenerate")):
    raise TypeError("Spyder type 'Polygon' is degenerate: it has no more than one required member, and the first member can be constructed from a string.\nPlease change the members, or inherit explicitly from Spyder.Degenerate")
spyder.__types__["Polygon"] = Polygon
spyder.core.error["Polygon"] = {}
if hasattr(Polygon, '_register_errors'): Polygon._register_errors()
Polygon._requiredmembers = [['CoordinateArray', 'vertices', 1]]
Polygon._defaultmembers = [['Material', 'material', '"defaultmaterial"', 2], ['AxisSystem', 'axis', 'AxisSystem()', 3], ['CoordinateArray', 'texturecoords', 'None', 4], ['Vector', 'normal', 'None', 5], ['VectorArray', 'vertexnormals', 'None', 6]]
Polygon.__form__()
ResourcePolygon = spyder.__types__["_Resource"](Polygon)

Polygon.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Polygon,
  "constructor_fromany",
)
Polygon.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Polygon,
  "constructor_fromany",
)
Polygon.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Polygon,
  "constructor_fromany",
)

class PolygonArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "PolygonArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, PolygonArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(PolygonArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (PolygonArray, target, self,deepcopy),
     name="PolygonArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(PolygonArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Polygon: self[vnr] = Polygon(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((PolygonArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((PolygonArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Polygon,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a PolygonArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    PolygonArray.__dict__[PolygonArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Polygon, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a PolygonArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("PolygonArray","Polygon","SPLIT")
spyder.core.defineconverter("Polygon","PolygonArray","CAST")
spyder.__types__["PolygonArray"] = globals()["PolygonArray"]  
arrayclass = spyder.__types__["PolygonArray"]
spyder.__types__["ResourcePolygonArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class PolygonArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "PolygonArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, PolygonArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(PolygonArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (PolygonArrayArray, target, self,deepcopy),
     name="PolygonArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(PolygonArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Polygon: self[vnr] = Polygon(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((PolygonArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((PolygonArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(PolygonArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a PolygonArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    PolygonArrayArray.__dict__[PolygonArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.PolygonArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a PolygonArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("PolygonArrayArray","PolygonArray","SPLIT")
spyder.core.defineconverter("PolygonArray","PolygonArrayArray","CAST")
spyder.__types__["PolygonArrayArray"] = globals()["PolygonArrayArray"]  
arrayclass = spyder.__types__["PolygonArrayArray"]
spyder.__types__["ResourcePolygonArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Vertex(Coordinate):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type Vertex(Coordinate) {
  *Coordinate2D texturecoords
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Vertex"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Vertex object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Vertex object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Vertex.__dict__[Vertex.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Vertex object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Vertex) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Vertex) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Vertex) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Vertex) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Vertex") and args[0][len("Vertex"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Vertex) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Vertex) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Vertex) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, x,y,z,texturecoords):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.x = reconstruct(self, Float,"x",x)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.y = reconstruct(self, Float,"y",y)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.z = reconstruct(self, Float,"z",z)
    except Exception as exc:
      exc.__context__ = None; raise
    self.texturecoords = None
    try:
      if texturecoords is not None: self.texturecoords = reconstruct(self, Coordinate2D,"texturecoords",texturecoords)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("x","y","z")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,x,y,z,texturecoords=None,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return x,y,z,texturecoords
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a.x
    except AttributeError:
      _missing_members.append('x')
    try:
      y = _a.y
    except AttributeError:
      _missing_members.append('y')
    try:
      z = _a.z
    except AttributeError:
      _missing_members.append('z')
    texturecoords = None
    if hasattr(_a,"texturecoords") and _a.texturecoords != None: texturecoords = _a.texturecoords
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (x,y,z,texturecoords,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      x = _a['x']
    except KeyError:
      _missing_members.append('x')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      y = _a['y']
    except KeyError:
      _missing_members.append('y')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      z = _a['z']
    except KeyError:
      _missing_members.append('z')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    texturecoords = None
    if "texturecoords" in _a: texturecoords = _a["texturecoords"]
    if isinstance(_a, dict) and "texturecoords" in _a: texturecoords = _a["texturecoords"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (x,y,z,texturecoords,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.x = Float(self.x)
      self.y = Float(self.y)
      self.z = Float(self.z)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.x
    if type(v) != Float: v = Float(v)
    ret += "%sx = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.y
    if type(v) != Float: v = Float(v)
    ret += "%sy = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.z
    if type(v) != Float: v = Float(v)
    ret += "%sz = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.texturecoords
    if v != None:
      if type(v) != Coordinate2D: v = Coordinate2D(v)
      ret += "%stexturecoords = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.x
    if type(v) != Float: v = Float(v)
    _d["x"] = v.dict()
    v = self.y
    if type(v) != Float: v = Float(v)
    _d["y"] = v.dict()
    v = self.z
    if type(v) != Float: v = Float(v)
    _d["z"] = v.dict()
    v = self.texturecoords
    if v != None:
      if type(v) != Coordinate2D: v = Coordinate2D(v)
      _d["texturecoords"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Vertex, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Vertex, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Vertex, target, self, deepcopy),
     name="Vertex=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Vertex) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.x != _a.x: return False
    if self.y != _a.y: return False
    if self.z != _a.z: return False
    if self.texturecoords != _a.texturecoords: return False
    try:
      if not Coordinate.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    x = self.x
    y = self.y
    z = self.z
    texturecoords = self.texturecoords
    x.default = 0
    y.default = 0    
    z.default = 0    
    x.digits = 3
    y.digits = 3
    z.digits = 3
  def __mul__(self, a): 
    """Multiplication with either:
      a Float (scaling)
      a Coordinate (dot product) 
      or an AxisSystem (vector-matrix multiplication)
    """
    types = (Float, Coordinate, AxisSystem)
    for t in types:  
      try:
        a = t(a)
      except:
        continue
      break
    else:
      raise TypeError("Unknown type")
    if t == Float: #scale
      return Coordinate(a*self.x,a*self.y, a*self.z)
    elif t == Coordinate: #dot product
      return a.x*self.x+a.y*self.y+a.z*self.z
    elif t == AxisSystem: #vector-matrix multiplication
      ret = Coordinate(a.origin)
      ret += self.x * a.x
      ret += self.y * a.y
      ret += self.z * a.z
      return ret
  def __rmul__(self, a):  
    """Inline multiplication"""
    return self * a
  def __truediv__(self, a):
    """Division by Float: equivalent to 1/a multiplication"""
    a = Float(a)
    return self * (1/a)
  def __div__(self, a):
    """Division by Float: equivalent to 1/a multiplication"""
    a = Float(a)
    return self * (1/a)
  def __rtruediv__(self, a):
    """Inline division by Float"""
    a = Float(a)
    return self * (1/a)
  def __rdiv__(self, a):
    """Inline division by Float"""
    a = Float(a)
    return self * (1/a)
  def size(self):
    """The scalar length of the Coordinate"""
    return sqrt(self.x**2+self.y**2+self.z**2)
  def normalize(self):
    """Re-scale the Coordinate length to 1 
    , returns Vector"""
    v = Coordinate(self)
    size = v.size()
    if size > 0: v /= size
    else: v = (1,0,0)
    return Vector(v)    
  def crossproduct(self, v):
    """Returns a Coordinate perpendicular both to this one and to v"""
    v = Coordinate(v)
    x = self.y * v.z - self.z * v.y
    y = self.z * v.x - self.x * v.z
    z = self.x * v.y - self.y * v.x
    return Coordinate(x,y,z).normalize()
  def __xor__(self,v): ## ^, cross product
    """Symbol ^, equivalent to crossproduct"""
    return self.crossproduct(v)
  def __neg__(self):
    """Negation, returns -self"""
    return type(self)(-self.x,-self.y,-self.z)
  def __add__(self, a):
    """Addition of another Coordinate"""
    a = Coordinate(a)
    return Coordinate(self.x+a.x, self.y+a.y, self.z+a.z)
  def __iadd__(self,a):
    """Inline addition"""
    self = type(self)(self + a)
    return self
  def __sub__(self,a):
    """Subtraction of another Coordinate"""
    return self + -a
  def __isub__(self,a):
    """Inline subtraction"""
    self = type(self)(self - a)
    return self
spyder.__types__["Vertex"] = Vertex
spyder.core.error["Vertex"] = {}
if hasattr(Vertex, '_register_errors'): Vertex._register_errors()
Vertex._requiredmembers = [['Float', 'x', 1], ['Float', 'y', 2], ['Float', 'z', 3]]
Vertex._defaultmembers = [['Coordinate2D', 'texturecoords', 'None', 4]]
Vertex.__form__()
ResourceVertex = spyder.__types__["_Resource"](Vertex)

Vertex.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Vertex,
  "constructor_fromany",
)
Vertex.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Vertex,
  "constructor_fromany",
)
Vertex.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Vertex,
  "constructor_fromany",
)

class VertexArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "VertexArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, VertexArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(VertexArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (VertexArray, target, self,deepcopy),
     name="VertexArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(VertexArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Vertex: self[vnr] = Vertex(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((VertexArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((VertexArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Vertex,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a VertexArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    VertexArray.__dict__[VertexArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Vertex, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a VertexArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("VertexArray","Vertex","SPLIT")
spyder.core.defineconverter("Vertex","VertexArray","CAST")
spyder.__types__["VertexArray"] = globals()["VertexArray"]  
arrayclass = spyder.__types__["VertexArray"]
spyder.__types__["ResourceVertexArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class VertexArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "VertexArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, VertexArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(VertexArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (VertexArrayArray, target, self,deepcopy),
     name="VertexArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(VertexArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Vertex: self[vnr] = Vertex(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((VertexArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((VertexArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(VertexArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a VertexArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    VertexArrayArray.__dict__[VertexArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.VertexArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a VertexArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("VertexArrayArray","VertexArray","SPLIT")
spyder.core.defineconverter("VertexArray","VertexArrayArray","CAST")
spyder.__types__["VertexArrayArray"] = globals()["VertexArrayArray"]  
arrayclass = spyder.__types__["VertexArrayArray"]
spyder.__types__["ResourceVertexArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Object3D(ThreeDee):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

Self-contained class for 3D object (mesh) data
  Every face contains indices that point to a vertex in "vertices"
  If a material other than "defaultmaterial" is used, 
   it must be elsewhere defined and show()'ed as a NewMaterial
  Edge specification is fully optional
  
----------------------------------------------------------------------
Spyder definition:

Type Object3D(ThreeDee) {
  #!#!#!
  Self-contained class for 3D object (mesh) data
  Every face contains indices that point to a vertex in "vertices"
  If a material other than "defaultmaterial" is used, 
   it must be elsewhere defined and show()'ed as a NewMaterial
  Edge specification is fully optional
  #!#!#!
  VertexArray vertices = []
  Face3DArray faces = []
  Material material = "defaultmaterial"
  AxisSystem axis = AxisSystem()
  Edge3DArray edges = [] 
  Enum lighting("smooth", "flat") = "flat"
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Object3D"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Object3D object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Object3D object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Object3D.__dict__[Object3D.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Object3D object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Object3D) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Object3D) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Object3D) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Object3D) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Object3D") and args[0][len("Object3D"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Object3D) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Object3D) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Object3D) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, vertices,faces,material,axis,edges,lighting):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if vertices is default0 or (vertices.__class__ is default0.__class__ and vertices == default0):      reconstruct_func = reconstruct_default
    try:
      self.vertices = reconstruct_func(self, VertexArray,"vertices",vertices)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if faces is default0 or (faces.__class__ is default0.__class__ and faces == default0):      reconstruct_func = reconstruct_default
    try:
      self.faces = reconstruct_func(self, Face3DArray,"faces",faces)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[2] if spyder.python3 else self.__unpack2__.func_defaults[2]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[3] if spyder.python3 else self.__unpack2__.func_defaults[3]
    if axis is default0 or (axis.__class__ is default0.__class__ and axis == default0):      reconstruct_func = reconstruct_default
    try:
      self.axis = reconstruct_func(self, AxisSystem,"axis",axis)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[4] if spyder.python3 else self.__unpack2__.func_defaults[4]
    if edges is default0 or (edges.__class__ is default0.__class__ and edges == default0):      reconstruct_func = reconstruct_default
    try:
      self.edges = reconstruct_func(self, Edge3DArray,"edges",edges)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[5] if spyder.python3 else self.__unpack2__.func_defaults[5]
    if lighting is default0 or (lighting.__class__ is default0.__class__ and lighting == default0):      reconstruct_func = reconstruct_default
    try:
      self.lighting = reconstruct_func(self, String,"lighting",lighting)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ()
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,vertices=[],faces=[],material="defaultmaterial",axis=AxisSystem(),edges=[],lighting="flat",*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return vertices,faces,material,axis,edges,lighting
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    ok = (_a == None or isinstance(_a,Object3D))
    vertices = []
    if hasattr(_a,"vertices") and _a.vertices != None:
      ok = True
      vertices = _a.vertices
    faces = []
    if hasattr(_a,"faces") and _a.faces != None:
      ok = True
      faces = _a.faces
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None:
      ok = True
      material = _a.material
    axis = AxisSystem()
    if hasattr(_a,"axis") and _a.axis != None:
      ok = True
      axis = _a.axis
    edges = []
    if hasattr(_a,"edges") and _a.edges != None:
      ok = True
      edges = _a.edges
    lighting = "flat"
    if hasattr(_a,"lighting") and _a.lighting != None:
      ok = True
      lighting = _a.lighting
    if ok == False: raise spyder.ConstructionError("Object '%s' has no matching attributes" % type(_a).__name__ )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (vertices,faces,material,axis,edges,lighting,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    ok = (_a == None or isinstance(_a, dict))
    vertices = []
    if "vertices" in _a:
      ok = True
      vertices = _a["vertices"]
    if isinstance(_a, dict) and "vertices" in _a: vertices = _a["vertices"]
    faces = []
    if "faces" in _a:
      ok = True
      faces = _a["faces"]
    if isinstance(_a, dict) and "faces" in _a: faces = _a["faces"]
    material = "defaultmaterial"
    if "material" in _a:
      ok = True
      material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    axis = AxisSystem()
    if "axis" in _a:
      ok = True
      axis = _a["axis"]
    if isinstance(_a, dict) and "axis" in _a: axis = _a["axis"]
    edges = []
    if "edges" in _a:
      ok = True
      edges = _a["edges"]
    if isinstance(_a, dict) and "edges" in _a: edges = _a["edges"]
    lighting = "flat"
    if "lighting" in _a:
      ok = True
      lighting = _a["lighting"]
    if isinstance(_a, dict) and "lighting" in _a: lighting = _a["lighting"]
    if ok == False: raise AttributeError
    return (vertices,faces,material,axis,edges,lighting,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.vertices = VertexArray(self.vertices)
      self.faces = Face3DArray(self.faces)
      self.material = Material(self.material)
      self.axis = AxisSystem(self.axis)
      self.edges = Edge3DArray(self.edges)
      self.lighting = String(self.lighting)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    vertices = self.vertices
    faces = self.faces
    material = self.material
    axis = self.axis
    edges = self.edges
    lighting = self.lighting
    if lighting is not None: spyder.core._assert(self, 'lighting in ("smooth", "flat")', 'if lighting is not None: assert lighting in ("smooth", "flat")')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'if lighting is not None: assert lighting in ("smooth", "flat")', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.vertices
    if type(v) != VertexArray: v = VertexArray(v)
    ret += "%svertices = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.faces
    if type(v) != Face3DArray: v = Face3DArray(v)
    ret += "%sfaces = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    ret += "%saxis = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.edges
    if type(v) != Edge3DArray: v = Edge3DArray(v)
    ret += "%sedges = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.lighting
    if type(v) != String: v = String(v)
    ret += "%slighting = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.vertices
    if type(v) != VertexArray: v = VertexArray(v)
    _d["vertices"] = v.dict()
    v = self.faces
    if type(v) != Face3DArray: v = Face3DArray(v)
    _d["faces"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    _d["axis"] = v.dict()
    v = self.edges
    if type(v) != Edge3DArray: v = Edge3DArray(v)
    _d["edges"] = v.dict()
    v = self.lighting
    if type(v) != String: v = String(v)
    _d["lighting"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Object3D, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Object3D, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Object3D, target, self, deepcopy),
     name="Object3D=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Object3D) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.vertices != _a.vertices: return False
    if self.faces != _a.faces: return False
    if self.material != _a.material: return False
    if self.axis != _a.axis: return False
    if self.edges != _a.edges: return False
    if self.lighting != _a.lighting: return False
    try:
      if not ThreeDee.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    vertices = self.vertices
    faces = self.faces
    material = self.material
    axis = self.axis
    edges = self.edges
    lighting = self.lighting
    lighting.options = "smooth", "flat"
spyder.__types__["Object3D"] = Object3D
spyder.core.error["Object3D"] = {}
if hasattr(Object3D, '_register_errors'): Object3D._register_errors()
Object3D._requiredmembers = []
Object3D._defaultmembers = [['VertexArray', 'vertices', '[]', 1], ['Face3DArray', 'faces', '[]', 2], ['Material', 'material', '"defaultmaterial"', 3], ['AxisSystem', 'axis', 'AxisSystem()', 4], ['Edge3DArray', 'edges', '[]', 5], ['String', 'lighting', '"flat"', 6]]
Object3D.__form__()
ResourceObject3D = spyder.__types__["_Resource"](Object3D)

Object3D.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Object3D,
  "constructor_fromany",
)
Object3D.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Object3D,
  "constructor_fromany",
)
Object3D.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Object3D,
  "constructor_fromany",
)

class Object3DArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Object3DArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Object3DArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Object3DArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Object3DArray, target, self,deepcopy),
     name="Object3DArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Object3DArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Object3D: self[vnr] = Object3D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Object3DArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Object3DArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Object3D,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Object3DArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Object3DArray.__dict__[Object3DArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Object3D, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Object3DArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Object3DArray","Object3D","SPLIT")
spyder.core.defineconverter("Object3D","Object3DArray","CAST")
spyder.__types__["Object3DArray"] = globals()["Object3DArray"]  
arrayclass = spyder.__types__["Object3DArray"]
spyder.__types__["ResourceObject3DArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Object3DArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Object3DArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Object3DArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Object3DArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Object3DArrayArray, target, self,deepcopy),
     name="Object3DArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Object3DArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Object3D: self[vnr] = Object3D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Object3DArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Object3DArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Object3DArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Object3DArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Object3DArrayArray.__dict__[Object3DArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Object3DArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Object3DArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Object3DArrayArray","Object3DArray","SPLIT")
spyder.core.defineconverter("Object3DArray","Object3DArrayArray","CAST")
spyder.__types__["Object3DArrayArray"] = globals()["Object3DArrayArray"]  
arrayclass = spyder.__types__["Object3DArrayArray"]
spyder.__types__["ResourceObject3DArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Block3D(ThreeDee):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

Class for rectangular blocks
----------------------------------------------------------------------
Spyder definition:

Type Block3D(ThreeDee) {
  #!#!#!
  Class for rectangular blocks
  #!#!#!
  Coordinate dimensions
  Material material = "defaultmaterial"
  AxisSystem axis = AxisSystem()
  Enum pivot("center", "corner") = "center"
  form {
    self.matrix = "axis"
    dimensions.default = Coordinate(1,1,1)
  }
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Block3D"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Block3D object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Block3D object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Block3D.__dict__[Block3D.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Block3D object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Block3D) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Block3D) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Block3D) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Block3D) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Block3D") and args[0][len("Block3D"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Block3D) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Block3D) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Block3D) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, dimensions,material,axis,pivot):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.dimensions = reconstruct(self, Coordinate,"dimensions",dimensions)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if axis is default0 or (axis.__class__ is default0.__class__ and axis == default0):      reconstruct_func = reconstruct_default
    try:
      self.axis = reconstruct_func(self, AxisSystem,"axis",axis)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[2] if spyder.python3 else self.__unpack2__.func_defaults[2]
    if pivot is default0 or (pivot.__class__ is default0.__class__ and pivot == default0):      reconstruct_func = reconstruct_default
    try:
      self.pivot = reconstruct_func(self, String,"pivot",pivot)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("dimensions",)
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,dimensions,material="defaultmaterial",axis=AxisSystem(),pivot="center",*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return dimensions,material,axis,pivot
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      dimensions = _a.dimensions
    except AttributeError:
      _missing_members.append('dimensions')
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    axis = AxisSystem()
    if hasattr(_a,"axis") and _a.axis != None: axis = _a.axis
    pivot = "center"
    if hasattr(_a,"pivot") and _a.pivot != None: pivot = _a.pivot
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (dimensions,material,axis,pivot,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      dimensions = _a['dimensions']
    except KeyError:
      _missing_members.append('dimensions')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    axis = AxisSystem()
    if "axis" in _a: axis = _a["axis"]
    if isinstance(_a, dict) and "axis" in _a: axis = _a["axis"]
    pivot = "center"
    if "pivot" in _a: pivot = _a["pivot"]
    if isinstance(_a, dict) and "pivot" in _a: pivot = _a["pivot"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (dimensions,material,axis,pivot,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.dimensions = Coordinate(self.dimensions)
      self.material = Material(self.material)
      self.axis = AxisSystem(self.axis)
      self.pivot = String(self.pivot)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    dimensions = self.dimensions
    material = self.material
    axis = self.axis
    pivot = self.pivot
    if pivot is not None: spyder.core._assert(self, 'pivot in ("center", "corner")', 'if pivot is not None: assert pivot in ("center", "corner")')
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    spyder.core._register_error(cls, 'if pivot is not None: assert pivot in ("center", "corner")', None)
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.dimensions
    if type(v) != Coordinate: v = Coordinate(v)
    ret += "%sdimensions = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    ret += "%saxis = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.pivot
    if type(v) != String: v = String(v)
    ret += "%spivot = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.dimensions
    if type(v) != Coordinate: v = Coordinate(v)
    _d["dimensions"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    _d["axis"] = v.dict()
    v = self.pivot
    if type(v) != String: v = String(v)
    _d["pivot"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Block3D, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Block3D, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Block3D, target, self, deepcopy),
     name="Block3D=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Block3D) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.dimensions != _a.dimensions: return False
    if self.material != _a.material: return False
    if self.axis != _a.axis: return False
    if self.pivot != _a.pivot: return False
    try:
      if not ThreeDee.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
    dimensions = self.dimensions
    material = self.material
    axis = self.axis
    pivot = self.pivot
    pivot.options = "center", "corner"
    self.matrix = "axis"
    dimensions.default = Coordinate(1,1,1)
if issubclass(Coordinate,Spyder.String) or issubclass(Coordinate,Spyder.Data):
  if not issubclass(Block3D,getattr(Spyder,"Degenerate")):
    raise TypeError("Spyder type 'Block3D' is degenerate: it has no more than one required member, and the first member can be constructed from a string.\nPlease change the members, or inherit explicitly from Spyder.Degenerate")
spyder.__types__["Block3D"] = Block3D
spyder.core.error["Block3D"] = {}
if hasattr(Block3D, '_register_errors'): Block3D._register_errors()
Block3D._requiredmembers = [['Coordinate', 'dimensions', 1]]
Block3D._defaultmembers = [['Material', 'material', '"defaultmaterial"', 2], ['AxisSystem', 'axis', 'AxisSystem()', 3], ['String', 'pivot', '"center"', 4]]
Block3D.__form__()
ResourceBlock3D = spyder.__types__["_Resource"](Block3D)

Block3D.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Block3D,
  "constructor_fromany",
)
Block3D.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Block3D,
  "constructor_fromany",
)
Block3D.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Block3D,
  "constructor_fromany",
)

class Block3DArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Block3DArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Block3DArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Block3DArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Block3DArray, target, self,deepcopy),
     name="Block3DArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Block3DArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Block3D: self[vnr] = Block3D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Block3DArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Block3DArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Block3D,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Block3DArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Block3DArray.__dict__[Block3DArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Block3D, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Block3DArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Block3DArray","Block3D","SPLIT")
spyder.core.defineconverter("Block3D","Block3DArray","CAST")
spyder.__types__["Block3DArray"] = globals()["Block3DArray"]  
arrayclass = spyder.__types__["Block3DArray"]
spyder.__types__["ResourceBlock3DArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Block3DArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Block3DArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Block3DArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Block3DArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Block3DArrayArray, target, self,deepcopy),
     name="Block3DArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Block3DArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Block3D: self[vnr] = Block3D(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Block3DArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Block3DArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Block3DArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Block3DArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Block3DArrayArray.__dict__[Block3DArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Block3DArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Block3DArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Block3DArrayArray","Block3DArray","SPLIT")
spyder.core.defineconverter("Block3DArray","Block3DArrayArray","CAST")
spyder.__types__["Block3DArrayArray"] = globals()["Block3DArrayArray"]  
arrayclass = spyder.__types__["Block3DArrayArray"]
spyder.__types__["ResourceBlock3DArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()

"""Define Block3D(Block3DArray) SPLIT"""
spyder.core.defineconverter("Block3DArray","Block3D","SPLIT")

class Circle(ThreeDee):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type Circle(ThreeDee) {
  Float radius
  Coordinate origin
  Material material = "defaultmaterial"
  Vector normal = (0,0,1)
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Circle"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Circle.__dict__[Circle.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Circle object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Circle) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Circle) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Circle) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Circle) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Circle") and args[0][len("Circle"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Circle) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Circle) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Circle) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, radius,origin,material,normal):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.radius = reconstruct(self, Float,"radius",radius)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.origin = reconstruct(self, Coordinate,"origin",origin)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if normal is default0 or (normal.__class__ is default0.__class__ and normal == default0):      reconstruct_func = reconstruct_default
    try:
      self.normal = reconstruct_func(self, Vector,"normal",normal)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("radius","origin")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,radius,origin,material="defaultmaterial",normal=(0,0,1),*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return radius,origin,material,normal
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a.radius
    except AttributeError:
      _missing_members.append('radius')
    try:
      origin = _a.origin
    except AttributeError:
      _missing_members.append('origin')
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    normal = (0,0,1)
    if hasattr(_a,"normal") and _a.normal != None: normal = _a.normal
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (radius,origin,material,normal,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a['radius']
    except KeyError:
      _missing_members.append('radius')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      origin = _a['origin']
    except KeyError:
      _missing_members.append('origin')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    normal = (0,0,1)
    if "normal" in _a: normal = _a["normal"]
    if isinstance(_a, dict) and "normal" in _a: normal = _a["normal"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (radius,origin,material,normal,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.radius = Float(self.radius)
      self.origin = Coordinate(self.origin)
      self.material = Material(self.material)
      self.normal = Vector(self.normal)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.radius
    if type(v) != Float: v = Float(v)
    ret += "%sradius = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    ret += "%sorigin = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.normal
    if type(v) != Vector: v = Vector(v)
    ret += "%snormal = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.radius
    if type(v) != Float: v = Float(v)
    _d["radius"] = v.dict()
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    _d["origin"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    v = self.normal
    if type(v) != Vector: v = Vector(v)
    _d["normal"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Circle, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Circle, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle, target, self, deepcopy),
     name="Circle=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Circle) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.radius != _a.radius: return False
    if self.origin != _a.origin: return False
    if self.material != _a.material: return False
    if self.normal != _a.normal: return False
    try:
      if not ThreeDee.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Circle"] = Circle
spyder.core.error["Circle"] = {}
if hasattr(Circle, '_register_errors'): Circle._register_errors()
Circle._requiredmembers = [['Float', 'radius', 1], ['Coordinate', 'origin', 2]]
Circle._defaultmembers = [['Material', 'material', '"defaultmaterial"', 3], ['Vector', 'normal', '(0,0,1)', 4]]
Circle.__form__()
ResourceCircle = spyder.__types__["_Resource"](Circle)

Circle.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Circle,
  "constructor_fromany",
)
Circle.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Circle,
  "constructor_fromany",
)
Circle.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Circle,
  "constructor_fromany",
)

class CircleArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "CircleArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, CircleArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(CircleArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (CircleArray, target, self,deepcopy),
     name="CircleArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(CircleArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Circle: self[vnr] = Circle(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((CircleArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((CircleArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Circle,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a CircleArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    CircleArray.__dict__[CircleArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Circle, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a CircleArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("CircleArray","Circle","SPLIT")
spyder.core.defineconverter("Circle","CircleArray","CAST")
spyder.__types__["CircleArray"] = globals()["CircleArray"]  
arrayclass = spyder.__types__["CircleArray"]
spyder.__types__["ResourceCircleArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class CircleArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "CircleArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, CircleArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(CircleArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (CircleArrayArray, target, self,deepcopy),
     name="CircleArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(CircleArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Circle: self[vnr] = Circle(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((CircleArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((CircleArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(CircleArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a CircleArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    CircleArrayArray.__dict__[CircleArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.CircleArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a CircleArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("CircleArrayArray","CircleArray","SPLIT")
spyder.core.defineconverter("CircleArray","CircleArrayArray","CAST")
spyder.__types__["CircleArrayArray"] = globals()["CircleArrayArray"]  
arrayclass = spyder.__types__["CircleArrayArray"]
spyder.__types__["ResourceCircleArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Circle16(Circle):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type Circle16(Circle) {
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Circle16"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle16 object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle16 object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Circle16.__dict__[Circle16.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Circle16 object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Circle16) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Circle16) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Circle16) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Circle16) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Circle16") and args[0][len("Circle16"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Circle16) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Circle16) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Circle16) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, radius,origin,material,normal):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.radius = reconstruct(self, Float,"radius",radius)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.origin = reconstruct(self, Coordinate,"origin",origin)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if normal is default0 or (normal.__class__ is default0.__class__ and normal == default0):      reconstruct_func = reconstruct_default
    try:
      self.normal = reconstruct_func(self, Vector,"normal",normal)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("radius","origin")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,radius,origin,material="defaultmaterial",normal=(0,0,1),*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return radius,origin,material,normal
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a.radius
    except AttributeError:
      _missing_members.append('radius')
    try:
      origin = _a.origin
    except AttributeError:
      _missing_members.append('origin')
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    normal = (0,0,1)
    if hasattr(_a,"normal") and _a.normal != None: normal = _a.normal
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (radius,origin,material,normal,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a['radius']
    except KeyError:
      _missing_members.append('radius')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      origin = _a['origin']
    except KeyError:
      _missing_members.append('origin')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    normal = (0,0,1)
    if "normal" in _a: normal = _a["normal"]
    if isinstance(_a, dict) and "normal" in _a: normal = _a["normal"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (radius,origin,material,normal,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.radius = Float(self.radius)
      self.origin = Coordinate(self.origin)
      self.material = Material(self.material)
      self.normal = Vector(self.normal)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.radius
    if type(v) != Float: v = Float(v)
    ret += "%sradius = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    ret += "%sorigin = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.normal
    if type(v) != Vector: v = Vector(v)
    ret += "%snormal = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.radius
    if type(v) != Float: v = Float(v)
    _d["radius"] = v.dict()
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    _d["origin"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    v = self.normal
    if type(v) != Vector: v = Vector(v)
    _d["normal"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Circle16, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Circle16, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle16, target, self, deepcopy),
     name="Circle16=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Circle16) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.radius != _a.radius: return False
    if self.origin != _a.origin: return False
    if self.material != _a.material: return False
    if self.normal != _a.normal: return False
    try:
      if not Circle.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Circle16"] = Circle16
spyder.core.error["Circle16"] = {}
if hasattr(Circle16, '_register_errors'): Circle16._register_errors()
Circle16._requiredmembers = [['Float', 'radius', 1], ['Coordinate', 'origin', 2]]
Circle16._defaultmembers = [['Material', 'material', '"defaultmaterial"', 3], ['Vector', 'normal', '(0,0,1)', 4]]
Circle16.__form__()
ResourceCircle16 = spyder.__types__["_Resource"](Circle16)

Circle16.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Circle16,
  "constructor_fromany",
)
Circle16.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Circle16,
  "constructor_fromany",
)
Circle16.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Circle16,
  "constructor_fromany",
)

class Circle16Array(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Circle16Array"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Circle16Array) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Circle16Array, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle16Array, target, self,deepcopy),
     name="Circle16Array=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Circle16Array, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Circle16: self[vnr] = Circle16(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Circle16Array, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Circle16Array, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Circle16,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Circle16Array object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Circle16Array.__dict__[Circle16Array.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Circle16, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle16Array object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Circle16Array","Circle16","SPLIT")
spyder.core.defineconverter("Circle16","Circle16Array","CAST")
spyder.__types__["Circle16Array"] = globals()["Circle16Array"]  
arrayclass = spyder.__types__["Circle16Array"]
spyder.__types__["ResourceCircle16Array"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Circle16ArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Circle16ArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Circle16ArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Circle16ArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle16ArrayArray, target, self,deepcopy),
     name="Circle16ArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Circle16ArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Circle16: self[vnr] = Circle16(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Circle16ArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Circle16ArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Circle16Array,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Circle16ArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Circle16ArrayArray.__dict__[Circle16ArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Circle16Array, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle16ArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Circle16ArrayArray","Circle16Array","SPLIT")
spyder.core.defineconverter("Circle16Array","Circle16ArrayArray","CAST")
spyder.__types__["Circle16ArrayArray"] = globals()["Circle16ArrayArray"]  
arrayclass = spyder.__types__["Circle16ArrayArray"]
spyder.__types__["ResourceCircle16ArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Circle32(Circle):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type Circle32(Circle) {
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Circle32"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle32 object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle32 object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Circle32.__dict__[Circle32.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Circle32 object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Circle32) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Circle32) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Circle32) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Circle32) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Circle32") and args[0][len("Circle32"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Circle32) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Circle32) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Circle32) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, radius,origin,material,normal):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.radius = reconstruct(self, Float,"radius",radius)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.origin = reconstruct(self, Coordinate,"origin",origin)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if normal is default0 or (normal.__class__ is default0.__class__ and normal == default0):      reconstruct_func = reconstruct_default
    try:
      self.normal = reconstruct_func(self, Vector,"normal",normal)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("radius","origin")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,radius,origin,material="defaultmaterial",normal=(0,0,1),*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return radius,origin,material,normal
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a.radius
    except AttributeError:
      _missing_members.append('radius')
    try:
      origin = _a.origin
    except AttributeError:
      _missing_members.append('origin')
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    normal = (0,0,1)
    if hasattr(_a,"normal") and _a.normal != None: normal = _a.normal
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (radius,origin,material,normal,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a['radius']
    except KeyError:
      _missing_members.append('radius')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      origin = _a['origin']
    except KeyError:
      _missing_members.append('origin')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    normal = (0,0,1)
    if "normal" in _a: normal = _a["normal"]
    if isinstance(_a, dict) and "normal" in _a: normal = _a["normal"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (radius,origin,material,normal,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.radius = Float(self.radius)
      self.origin = Coordinate(self.origin)
      self.material = Material(self.material)
      self.normal = Vector(self.normal)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.radius
    if type(v) != Float: v = Float(v)
    ret += "%sradius = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    ret += "%sorigin = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.normal
    if type(v) != Vector: v = Vector(v)
    ret += "%snormal = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.radius
    if type(v) != Float: v = Float(v)
    _d["radius"] = v.dict()
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    _d["origin"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    v = self.normal
    if type(v) != Vector: v = Vector(v)
    _d["normal"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Circle32, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Circle32, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle32, target, self, deepcopy),
     name="Circle32=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Circle32) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.radius != _a.radius: return False
    if self.origin != _a.origin: return False
    if self.material != _a.material: return False
    if self.normal != _a.normal: return False
    try:
      if not Circle.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Circle32"] = Circle32
spyder.core.error["Circle32"] = {}
if hasattr(Circle32, '_register_errors'): Circle32._register_errors()
Circle32._requiredmembers = [['Float', 'radius', 1], ['Coordinate', 'origin', 2]]
Circle32._defaultmembers = [['Material', 'material', '"defaultmaterial"', 3], ['Vector', 'normal', '(0,0,1)', 4]]
Circle32.__form__()
ResourceCircle32 = spyder.__types__["_Resource"](Circle32)

Circle32.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Circle32,
  "constructor_fromany",
)
Circle32.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Circle32,
  "constructor_fromany",
)
Circle32.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Circle32,
  "constructor_fromany",
)

class Circle32Array(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Circle32Array"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Circle32Array) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Circle32Array, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle32Array, target, self,deepcopy),
     name="Circle32Array=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Circle32Array, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Circle32: self[vnr] = Circle32(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Circle32Array, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Circle32Array, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Circle32,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Circle32Array object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Circle32Array.__dict__[Circle32Array.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Circle32, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle32Array object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Circle32Array","Circle32","SPLIT")
spyder.core.defineconverter("Circle32","Circle32Array","CAST")
spyder.__types__["Circle32Array"] = globals()["Circle32Array"]  
arrayclass = spyder.__types__["Circle32Array"]
spyder.__types__["ResourceCircle32Array"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Circle32ArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Circle32ArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Circle32ArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Circle32ArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle32ArrayArray, target, self,deepcopy),
     name="Circle32ArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Circle32ArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Circle32: self[vnr] = Circle32(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Circle32ArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Circle32ArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Circle32Array,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Circle32ArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Circle32ArrayArray.__dict__[Circle32ArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Circle32Array, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle32ArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Circle32ArrayArray","Circle32Array","SPLIT")
spyder.core.defineconverter("Circle32Array","Circle32ArrayArray","CAST")
spyder.__types__["Circle32ArrayArray"] = globals()["Circle32ArrayArray"]  
arrayclass = spyder.__types__["Circle32ArrayArray"]
spyder.__types__["ResourceCircle32ArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Circle64(Circle):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type Circle64(Circle) {
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Circle64"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle64 object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle64 object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Circle64.__dict__[Circle64.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Circle64 object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Circle64) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Circle64) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Circle64) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Circle64) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Circle64") and args[0][len("Circle64"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Circle64) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Circle64) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Circle64) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, radius,origin,material,normal):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.radius = reconstruct(self, Float,"radius",radius)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.origin = reconstruct(self, Coordinate,"origin",origin)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if normal is default0 or (normal.__class__ is default0.__class__ and normal == default0):      reconstruct_func = reconstruct_default
    try:
      self.normal = reconstruct_func(self, Vector,"normal",normal)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("radius","origin")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,radius,origin,material="defaultmaterial",normal=(0,0,1),*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return radius,origin,material,normal
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a.radius
    except AttributeError:
      _missing_members.append('radius')
    try:
      origin = _a.origin
    except AttributeError:
      _missing_members.append('origin')
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    normal = (0,0,1)
    if hasattr(_a,"normal") and _a.normal != None: normal = _a.normal
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (radius,origin,material,normal,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a['radius']
    except KeyError:
      _missing_members.append('radius')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      origin = _a['origin']
    except KeyError:
      _missing_members.append('origin')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    normal = (0,0,1)
    if "normal" in _a: normal = _a["normal"]
    if isinstance(_a, dict) and "normal" in _a: normal = _a["normal"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (radius,origin,material,normal,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.radius = Float(self.radius)
      self.origin = Coordinate(self.origin)
      self.material = Material(self.material)
      self.normal = Vector(self.normal)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.radius
    if type(v) != Float: v = Float(v)
    ret += "%sradius = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    ret += "%sorigin = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.normal
    if type(v) != Vector: v = Vector(v)
    ret += "%snormal = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.radius
    if type(v) != Float: v = Float(v)
    _d["radius"] = v.dict()
    v = self.origin
    if type(v) != Coordinate: v = Coordinate(v)
    _d["origin"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    v = self.normal
    if type(v) != Vector: v = Vector(v)
    _d["normal"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Circle64, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Circle64, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle64, target, self, deepcopy),
     name="Circle64=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Circle64) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.radius != _a.radius: return False
    if self.origin != _a.origin: return False
    if self.material != _a.material: return False
    if self.normal != _a.normal: return False
    try:
      if not Circle.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Circle64"] = Circle64
spyder.core.error["Circle64"] = {}
if hasattr(Circle64, '_register_errors'): Circle64._register_errors()
Circle64._requiredmembers = [['Float', 'radius', 1], ['Coordinate', 'origin', 2]]
Circle64._defaultmembers = [['Material', 'material', '"defaultmaterial"', 3], ['Vector', 'normal', '(0,0,1)', 4]]
Circle64.__form__()
ResourceCircle64 = spyder.__types__["_Resource"](Circle64)

Circle64.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Circle64,
  "constructor_fromany",
)
Circle64.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Circle64,
  "constructor_fromany",
)
Circle64.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Circle64,
  "constructor_fromany",
)

class Circle64Array(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Circle64Array"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Circle64Array) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Circle64Array, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle64Array, target, self,deepcopy),
     name="Circle64Array=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Circle64Array, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Circle64: self[vnr] = Circle64(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Circle64Array, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Circle64Array, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Circle64,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Circle64Array object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Circle64Array.__dict__[Circle64Array.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Circle64, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle64Array object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Circle64Array","Circle64","SPLIT")
spyder.core.defineconverter("Circle64","Circle64Array","CAST")
spyder.__types__["Circle64Array"] = globals()["Circle64Array"]  
arrayclass = spyder.__types__["Circle64Array"]
spyder.__types__["ResourceCircle64Array"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Circle64ArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Circle64ArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Circle64ArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Circle64ArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Circle64ArrayArray, target, self,deepcopy),
     name="Circle64ArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Circle64ArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Circle64: self[vnr] = Circle64(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Circle64ArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Circle64ArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Circle64Array,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Circle64ArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Circle64ArrayArray.__dict__[Circle64ArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Circle64Array, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Circle64ArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Circle64ArrayArray","Circle64Array","SPLIT")
spyder.core.defineconverter("Circle64Array","Circle64ArrayArray","CAST")
spyder.__types__["Circle64ArrayArray"] = globals()["Circle64ArrayArray"]  
arrayclass = spyder.__types__["Circle64ArrayArray"]
spyder.__types__["ResourceCircle64ArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()

"""Define Circle64(Circle) CAST"""
spyder.core.defineconverter("Circle","Circle64","CAST")

class Cylinder(ThreeDee):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

Defines a cylinder with its symmetry axis defined as axis.z
   and going through axis.origin
  The cylinder can be scaled using radius and height, 
   or by scaling axis.x/y/z
  
----------------------------------------------------------------------
Spyder definition:

Type Cylinder(ThreeDee) {
  #!#!#!
  Defines a cylinder with its symmetry axis defined as axis.z
   and going through axis.origin
  The cylinder can be scaled using radius and height, 
   or by scaling axis.x/y/z
  #!#!#!
  Float radius
  Float height
  AxisSystem axis = AxisSystem()
  Material material = "defaultmaterial"
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Cylinder"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Cylinder.__dict__[Cylinder.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Cylinder object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Cylinder) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Cylinder) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Cylinder) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Cylinder) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Cylinder") and args[0][len("Cylinder"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Cylinder) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Cylinder) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Cylinder) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, radius,height,axis,material):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.radius = reconstruct(self, Float,"radius",radius)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.height = reconstruct(self, Float,"height",height)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if axis is default0 or (axis.__class__ is default0.__class__ and axis == default0):      reconstruct_func = reconstruct_default
    try:
      self.axis = reconstruct_func(self, AxisSystem,"axis",axis)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("radius","height")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,radius,height,axis=AxisSystem(),material="defaultmaterial",*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return radius,height,axis,material
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a.radius
    except AttributeError:
      _missing_members.append('radius')
    try:
      height = _a.height
    except AttributeError:
      _missing_members.append('height')
    axis = AxisSystem()
    if hasattr(_a,"axis") and _a.axis != None: axis = _a.axis
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (radius,height,axis,material,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a['radius']
    except KeyError:
      _missing_members.append('radius')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      height = _a['height']
    except KeyError:
      _missing_members.append('height')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    axis = AxisSystem()
    if "axis" in _a: axis = _a["axis"]
    if isinstance(_a, dict) and "axis" in _a: axis = _a["axis"]
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (radius,height,axis,material,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.radius = Float(self.radius)
      self.height = Float(self.height)
      self.axis = AxisSystem(self.axis)
      self.material = Material(self.material)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.radius
    if type(v) != Float: v = Float(v)
    ret += "%sradius = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.height
    if type(v) != Float: v = Float(v)
    ret += "%sheight = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    ret += "%saxis = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.radius
    if type(v) != Float: v = Float(v)
    _d["radius"] = v.dict()
    v = self.height
    if type(v) != Float: v = Float(v)
    _d["height"] = v.dict()
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    _d["axis"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Cylinder, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Cylinder, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder, target, self, deepcopy),
     name="Cylinder=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Cylinder) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.radius != _a.radius: return False
    if self.height != _a.height: return False
    if self.axis != _a.axis: return False
    if self.material != _a.material: return False
    try:
      if not ThreeDee.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Cylinder"] = Cylinder
spyder.core.error["Cylinder"] = {}
if hasattr(Cylinder, '_register_errors'): Cylinder._register_errors()
Cylinder._requiredmembers = [['Float', 'radius', 1], ['Float', 'height', 2]]
Cylinder._defaultmembers = [['AxisSystem', 'axis', 'AxisSystem()', 3], ['Material', 'material', '"defaultmaterial"', 4]]
Cylinder.__form__()
ResourceCylinder = spyder.__types__["_Resource"](Cylinder)

Cylinder.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Cylinder,
  "constructor_fromany",
)
Cylinder.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Cylinder,
  "constructor_fromany",
)
Cylinder.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Cylinder,
  "constructor_fromany",
)

class CylinderArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "CylinderArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, CylinderArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(CylinderArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (CylinderArray, target, self,deepcopy),
     name="CylinderArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(CylinderArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Cylinder: self[vnr] = Cylinder(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((CylinderArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((CylinderArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Cylinder,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a CylinderArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    CylinderArray.__dict__[CylinderArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Cylinder, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a CylinderArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("CylinderArray","Cylinder","SPLIT")
spyder.core.defineconverter("Cylinder","CylinderArray","CAST")
spyder.__types__["CylinderArray"] = globals()["CylinderArray"]  
arrayclass = spyder.__types__["CylinderArray"]
spyder.__types__["ResourceCylinderArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class CylinderArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "CylinderArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, CylinderArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(CylinderArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (CylinderArrayArray, target, self,deepcopy),
     name="CylinderArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(CylinderArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Cylinder: self[vnr] = Cylinder(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((CylinderArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((CylinderArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(CylinderArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a CylinderArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    CylinderArrayArray.__dict__[CylinderArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.CylinderArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a CylinderArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("CylinderArrayArray","CylinderArray","SPLIT")
spyder.core.defineconverter("CylinderArray","CylinderArrayArray","CAST")
spyder.__types__["CylinderArrayArray"] = globals()["CylinderArrayArray"]  
arrayclass = spyder.__types__["CylinderArrayArray"]
spyder.__types__["ResourceCylinderArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Cylinder16(Cylinder):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type Cylinder16(Cylinder) {
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Cylinder16"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder16 object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder16 object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Cylinder16.__dict__[Cylinder16.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Cylinder16 object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Cylinder16) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Cylinder16) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Cylinder16) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Cylinder16) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Cylinder16") and args[0][len("Cylinder16"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Cylinder16) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Cylinder16) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Cylinder16) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, radius,height,axis,material):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.radius = reconstruct(self, Float,"radius",radius)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.height = reconstruct(self, Float,"height",height)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if axis is default0 or (axis.__class__ is default0.__class__ and axis == default0):      reconstruct_func = reconstruct_default
    try:
      self.axis = reconstruct_func(self, AxisSystem,"axis",axis)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("radius","height")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,radius,height,axis=AxisSystem(),material="defaultmaterial",*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return radius,height,axis,material
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a.radius
    except AttributeError:
      _missing_members.append('radius')
    try:
      height = _a.height
    except AttributeError:
      _missing_members.append('height')
    axis = AxisSystem()
    if hasattr(_a,"axis") and _a.axis != None: axis = _a.axis
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (radius,height,axis,material,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a['radius']
    except KeyError:
      _missing_members.append('radius')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      height = _a['height']
    except KeyError:
      _missing_members.append('height')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    axis = AxisSystem()
    if "axis" in _a: axis = _a["axis"]
    if isinstance(_a, dict) and "axis" in _a: axis = _a["axis"]
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (radius,height,axis,material,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.radius = Float(self.radius)
      self.height = Float(self.height)
      self.axis = AxisSystem(self.axis)
      self.material = Material(self.material)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.radius
    if type(v) != Float: v = Float(v)
    ret += "%sradius = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.height
    if type(v) != Float: v = Float(v)
    ret += "%sheight = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    ret += "%saxis = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.radius
    if type(v) != Float: v = Float(v)
    _d["radius"] = v.dict()
    v = self.height
    if type(v) != Float: v = Float(v)
    _d["height"] = v.dict()
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    _d["axis"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Cylinder16, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Cylinder16, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder16, target, self, deepcopy),
     name="Cylinder16=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Cylinder16) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.radius != _a.radius: return False
    if self.height != _a.height: return False
    if self.axis != _a.axis: return False
    if self.material != _a.material: return False
    try:
      if not Cylinder.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Cylinder16"] = Cylinder16
spyder.core.error["Cylinder16"] = {}
if hasattr(Cylinder16, '_register_errors'): Cylinder16._register_errors()
Cylinder16._requiredmembers = [['Float', 'radius', 1], ['Float', 'height', 2]]
Cylinder16._defaultmembers = [['AxisSystem', 'axis', 'AxisSystem()', 3], ['Material', 'material', '"defaultmaterial"', 4]]
Cylinder16.__form__()
ResourceCylinder16 = spyder.__types__["_Resource"](Cylinder16)

Cylinder16.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Cylinder16,
  "constructor_fromany",
)
Cylinder16.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Cylinder16,
  "constructor_fromany",
)
Cylinder16.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Cylinder16,
  "constructor_fromany",
)

class Cylinder16Array(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Cylinder16Array"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Cylinder16Array) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Cylinder16Array, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder16Array, target, self,deepcopy),
     name="Cylinder16Array=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Cylinder16Array, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Cylinder16: self[vnr] = Cylinder16(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Cylinder16Array, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Cylinder16Array, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Cylinder16,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder16Array object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Cylinder16Array.__dict__[Cylinder16Array.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Cylinder16, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder16Array object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Cylinder16Array","Cylinder16","SPLIT")
spyder.core.defineconverter("Cylinder16","Cylinder16Array","CAST")
spyder.__types__["Cylinder16Array"] = globals()["Cylinder16Array"]  
arrayclass = spyder.__types__["Cylinder16Array"]
spyder.__types__["ResourceCylinder16Array"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Cylinder16ArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Cylinder16ArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Cylinder16ArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Cylinder16ArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder16ArrayArray, target, self,deepcopy),
     name="Cylinder16ArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Cylinder16ArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Cylinder16: self[vnr] = Cylinder16(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Cylinder16ArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Cylinder16ArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Cylinder16Array,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder16ArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Cylinder16ArrayArray.__dict__[Cylinder16ArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Cylinder16Array, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder16ArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Cylinder16ArrayArray","Cylinder16Array","SPLIT")
spyder.core.defineconverter("Cylinder16Array","Cylinder16ArrayArray","CAST")
spyder.__types__["Cylinder16ArrayArray"] = globals()["Cylinder16ArrayArray"]  
arrayclass = spyder.__types__["Cylinder16ArrayArray"]
spyder.__types__["ResourceCylinder16ArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Cylinder32(Cylinder):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type Cylinder32(Cylinder) {
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Cylinder32"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder32 object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder32 object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Cylinder32.__dict__[Cylinder32.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Cylinder32 object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Cylinder32) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Cylinder32) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Cylinder32) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Cylinder32) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Cylinder32") and args[0][len("Cylinder32"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Cylinder32) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Cylinder32) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Cylinder32) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, radius,height,axis,material):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.radius = reconstruct(self, Float,"radius",radius)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.height = reconstruct(self, Float,"height",height)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if axis is default0 or (axis.__class__ is default0.__class__ and axis == default0):      reconstruct_func = reconstruct_default
    try:
      self.axis = reconstruct_func(self, AxisSystem,"axis",axis)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("radius","height")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,radius,height,axis=AxisSystem(),material="defaultmaterial",*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return radius,height,axis,material
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a.radius
    except AttributeError:
      _missing_members.append('radius')
    try:
      height = _a.height
    except AttributeError:
      _missing_members.append('height')
    axis = AxisSystem()
    if hasattr(_a,"axis") and _a.axis != None: axis = _a.axis
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (radius,height,axis,material,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a['radius']
    except KeyError:
      _missing_members.append('radius')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      height = _a['height']
    except KeyError:
      _missing_members.append('height')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    axis = AxisSystem()
    if "axis" in _a: axis = _a["axis"]
    if isinstance(_a, dict) and "axis" in _a: axis = _a["axis"]
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (radius,height,axis,material,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.radius = Float(self.radius)
      self.height = Float(self.height)
      self.axis = AxisSystem(self.axis)
      self.material = Material(self.material)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.radius
    if type(v) != Float: v = Float(v)
    ret += "%sradius = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.height
    if type(v) != Float: v = Float(v)
    ret += "%sheight = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    ret += "%saxis = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.radius
    if type(v) != Float: v = Float(v)
    _d["radius"] = v.dict()
    v = self.height
    if type(v) != Float: v = Float(v)
    _d["height"] = v.dict()
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    _d["axis"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Cylinder32, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Cylinder32, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder32, target, self, deepcopy),
     name="Cylinder32=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Cylinder32) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.radius != _a.radius: return False
    if self.height != _a.height: return False
    if self.axis != _a.axis: return False
    if self.material != _a.material: return False
    try:
      if not Cylinder.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Cylinder32"] = Cylinder32
spyder.core.error["Cylinder32"] = {}
if hasattr(Cylinder32, '_register_errors'): Cylinder32._register_errors()
Cylinder32._requiredmembers = [['Float', 'radius', 1], ['Float', 'height', 2]]
Cylinder32._defaultmembers = [['AxisSystem', 'axis', 'AxisSystem()', 3], ['Material', 'material', '"defaultmaterial"', 4]]
Cylinder32.__form__()
ResourceCylinder32 = spyder.__types__["_Resource"](Cylinder32)

Cylinder32.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Cylinder32,
  "constructor_fromany",
)
Cylinder32.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Cylinder32,
  "constructor_fromany",
)
Cylinder32.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Cylinder32,
  "constructor_fromany",
)

class Cylinder32Array(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Cylinder32Array"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Cylinder32Array) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Cylinder32Array, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder32Array, target, self,deepcopy),
     name="Cylinder32Array=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Cylinder32Array, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Cylinder32: self[vnr] = Cylinder32(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Cylinder32Array, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Cylinder32Array, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Cylinder32,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder32Array object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Cylinder32Array.__dict__[Cylinder32Array.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Cylinder32, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder32Array object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Cylinder32Array","Cylinder32","SPLIT")
spyder.core.defineconverter("Cylinder32","Cylinder32Array","CAST")
spyder.__types__["Cylinder32Array"] = globals()["Cylinder32Array"]  
arrayclass = spyder.__types__["Cylinder32Array"]
spyder.__types__["ResourceCylinder32Array"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Cylinder32ArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Cylinder32ArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Cylinder32ArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Cylinder32ArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder32ArrayArray, target, self,deepcopy),
     name="Cylinder32ArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Cylinder32ArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Cylinder32: self[vnr] = Cylinder32(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Cylinder32ArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Cylinder32ArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Cylinder32Array,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder32ArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Cylinder32ArrayArray.__dict__[Cylinder32ArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Cylinder32Array, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder32ArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Cylinder32ArrayArray","Cylinder32Array","SPLIT")
spyder.core.defineconverter("Cylinder32Array","Cylinder32ArrayArray","CAST")
spyder.__types__["Cylinder32ArrayArray"] = globals()["Cylinder32ArrayArray"]  
arrayclass = spyder.__types__["Cylinder32ArrayArray"]
spyder.__types__["ResourceCylinder32ArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class Cylinder64(Cylinder):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'


----------------------------------------------------------------------
Spyder definition:

Type Cylinder64(Cylinder) {
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "Cylinder64"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder64 object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder64 object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    Cylinder64.__dict__[Cylinder64.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a Cylinder64 object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (Cylinder64) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (Cylinder64) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (Cylinder64) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (Cylinder64) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("Cylinder64") and args[0][len("Cylinder64"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (Cylinder64) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (Cylinder64) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (Cylinder64) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, radius,height,axis,material):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.radius = reconstruct(self, Float,"radius",radius)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.height = reconstruct(self, Float,"height",height)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if axis is default0 or (axis.__class__ is default0.__class__ and axis == default0):      reconstruct_func = reconstruct_default
    try:
      self.axis = reconstruct_func(self, AxisSystem,"axis",axis)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[1] if spyder.python3 else self.__unpack2__.func_defaults[1]
    if material is default0 or (material.__class__ is default0.__class__ and material == default0):      reconstruct_func = reconstruct_default
    try:
      self.material = reconstruct_func(self, Material,"material",material)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("radius","height")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,radius,height,axis=AxisSystem(),material="defaultmaterial",*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return radius,height,axis,material
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a.radius
    except AttributeError:
      _missing_members.append('radius')
    try:
      height = _a.height
    except AttributeError:
      _missing_members.append('height')
    axis = AxisSystem()
    if hasattr(_a,"axis") and _a.axis != None: axis = _a.axis
    material = "defaultmaterial"
    if hasattr(_a,"material") and _a.material != None: material = _a.material
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (radius,height,axis,material,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      radius = _a['radius']
    except KeyError:
      _missing_members.append('radius')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      height = _a['height']
    except KeyError:
      _missing_members.append('height')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    axis = AxisSystem()
    if "axis" in _a: axis = _a["axis"]
    if isinstance(_a, dict) and "axis" in _a: axis = _a["axis"]
    material = "defaultmaterial"
    if "material" in _a: material = _a["material"]
    if isinstance(_a, dict) and "material" in _a: material = _a["material"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (radius,height,axis,material,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.radius = Float(self.radius)
      self.height = Float(self.height)
      self.axis = AxisSystem(self.axis)
      self.material = Material(self.material)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.radius
    if type(v) != Float: v = Float(v)
    ret += "%sradius = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.height
    if type(v) != Float: v = Float(v)
    ret += "%sheight = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    ret += "%saxis = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.material
    if type(v) != Material: v = Material(v)
    ret += "%smaterial = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.radius
    if type(v) != Float: v = Float(v)
    _d["radius"] = v.dict()
    v = self.height
    if type(v) != Float: v = Float(v)
    _d["height"] = v.dict()
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    _d["axis"] = v.dict()
    v = self.material
    if type(v) != Material: v = Material(v)
    _d["material"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(Cylinder64, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(Cylinder64, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder64, target, self, deepcopy),
     name="Cylinder64=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,Cylinder64) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.radius != _a.radius: return False
    if self.height != _a.height: return False
    if self.axis != _a.axis: return False
    if self.material != _a.material: return False
    try:
      if not Cylinder.__eq__(self, _a): return False
    except AttributeError:
      pass
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["Cylinder64"] = Cylinder64
spyder.core.error["Cylinder64"] = {}
if hasattr(Cylinder64, '_register_errors'): Cylinder64._register_errors()
Cylinder64._requiredmembers = [['Float', 'radius', 1], ['Float', 'height', 2]]
Cylinder64._defaultmembers = [['AxisSystem', 'axis', 'AxisSystem()', 3], ['Material', 'material', '"defaultmaterial"', 4]]
Cylinder64.__form__()
ResourceCylinder64 = spyder.__types__["_Resource"](Cylinder64)

Cylinder64.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  Cylinder64,
  "constructor_fromany",
)
Cylinder64.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  Cylinder64,
  "constructor_fromany",
)
Cylinder64.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  Cylinder64,
  "constructor_fromany",
)

class Cylinder64Array(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Cylinder64Array"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Cylinder64Array) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Cylinder64Array, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder64Array, target, self,deepcopy),
     name="Cylinder64Array=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Cylinder64Array, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Cylinder64: self[vnr] = Cylinder64(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Cylinder64Array, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Cylinder64Array, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Cylinder64,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder64Array object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Cylinder64Array.__dict__[Cylinder64Array.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Cylinder64, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder64Array object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Cylinder64Array","Cylinder64","SPLIT")
spyder.core.defineconverter("Cylinder64","Cylinder64Array","CAST")
spyder.__types__["Cylinder64Array"] = globals()["Cylinder64Array"]  
arrayclass = spyder.__types__["Cylinder64Array"]
spyder.__types__["ResourceCylinder64Array"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class Cylinder64ArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "Cylinder64ArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, Cylinder64ArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(Cylinder64ArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (Cylinder64ArrayArray, target, self,deepcopy),
     name="Cylinder64ArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(Cylinder64ArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != Cylinder64: self[vnr] = Cylinder64(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((Cylinder64ArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((Cylinder64ArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(Cylinder64Array,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder64ArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    Cylinder64ArrayArray.__dict__[Cylinder64ArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.Cylinder64Array, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a Cylinder64ArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("Cylinder64ArrayArray","Cylinder64Array","SPLIT")
spyder.core.defineconverter("Cylinder64Array","Cylinder64ArrayArray","CAST")
spyder.__types__["Cylinder64ArrayArray"] = globals()["Cylinder64ArrayArray"]  
arrayclass = spyder.__types__["Cylinder64ArrayArray"]
spyder.__types__["ResourceCylinder64ArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()

"""Define Cylinder32(Cylinder) CAST"""
spyder.core.defineconverter("Cylinder","Cylinder32","CAST")
"""Define Object3D(Circle16) drawCircle16"""
spyder.core.defineconverter("Circle16","Object3D",drawCircle16)
"""Define Object3D(Circle32) drawCircle32"""
spyder.core.defineconverter("Circle32","Object3D",drawCircle32)
"""Define Object3D(Circle64) drawCircle64"""
spyder.core.defineconverter("Circle64","Object3D",drawCircle64)
"""Define Object3D(Cylinder16) drawCylinder16"""
spyder.core.defineconverter("Cylinder16","Object3D",drawCylinder16)
"""Define Object3D(Cylinder32) drawCylinder32"""
spyder.core.defineconverter("Cylinder32","Object3D",drawCylinder32)
"""Define Object3D(Cylinder64) drawCylinder64"""
spyder.core.defineconverter("Cylinder64","Object3D",drawCylinder64)
"""Define Object3D(Object3DArray) SPLIT"""
spyder.core.defineconverter("Object3DArray","Object3D","SPLIT")

class DisplayList(Object):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

If objects are show()'ed in Tarantula, 
   an integer OpenGL display list is typically returned.
   This class specifies a display list to be 
    show()'ed again, multiplied with an AxisSystem
  
----------------------------------------------------------------------
Spyder definition:

Type DisplayList {
  #!#!#!
  If objects are show()'ed in Tarantula, 
   an integer OpenGL display list is typically returned.
   This class specifies a display list to be 
    show()'ed again, multiplied with an AxisSystem
  #!#!#!
  Integer displaylist
  AxisSystem axis = AxisSystem()
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "DisplayList"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DisplayList object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DisplayList object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    DisplayList.__dict__[DisplayList.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a DisplayList object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (DisplayList) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (DisplayList) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (DisplayList) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (DisplayList) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("DisplayList") and args[0][len("DisplayList"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (DisplayList) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (DisplayList) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (DisplayList) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, displaylist,axis):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.displaylist = reconstruct(self, Integer,"displaylist",displaylist)
    except Exception as exc:
      exc.__context__ = None; raise
    reconstruct_func = reconstruct 
    default0 = self.__unpack2__.__defaults__[0] if spyder.python3 else self.__unpack2__.func_defaults[0]
    if axis is default0 or (axis.__class__ is default0.__class__ and axis == default0):      reconstruct_func = reconstruct_default
    try:
      self.axis = reconstruct_func(self, AxisSystem,"axis",axis)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("displaylist",)
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,displaylist,axis=AxisSystem(),*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return displaylist,axis
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      displaylist = _a.displaylist
    except AttributeError:
      _missing_members.append('displaylist')
    axis = AxisSystem()
    if hasattr(_a,"axis") and _a.axis != None: axis = _a.axis
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (displaylist,axis,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      displaylist = _a['displaylist']
    except KeyError:
      _missing_members.append('displaylist')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    axis = AxisSystem()
    if "axis" in _a: axis = _a["axis"]
    if isinstance(_a, dict) and "axis" in _a: axis = _a["axis"]
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (displaylist,axis,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.displaylist = Integer(self.displaylist)
      self.axis = AxisSystem(self.axis)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.displaylist
    if type(v) != Integer: v = Integer(v)
    ret += "%sdisplaylist = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    ret += "%saxis = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.displaylist
    if type(v) != Integer: v = Integer(v)
    _d["displaylist"] = v.dict()
    v = self.axis
    if type(v) != AxisSystem: v = AxisSystem(v)
    _d["axis"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(DisplayList, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(DisplayList, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DisplayList, target, self, deepcopy),
     name="DisplayList=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,DisplayList) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.displaylist != _a.displaylist: return False
    if self.axis != _a.axis: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
if issubclass(Integer,Spyder.String) or issubclass(Integer,Spyder.Data):
  if not issubclass(DisplayList,getattr(Spyder,"Degenerate")):
    raise TypeError("Spyder type 'DisplayList' is degenerate: it has no more than one required member, and the first member can be constructed from a string.\nPlease change the members, or inherit explicitly from Spyder.Degenerate")
spyder.__types__["DisplayList"] = DisplayList
spyder.core.error["DisplayList"] = {}
if hasattr(DisplayList, '_register_errors'): DisplayList._register_errors()
DisplayList._requiredmembers = [['Integer', 'displaylist', 1]]
DisplayList._defaultmembers = [['AxisSystem', 'axis', 'AxisSystem()', 2]]
DisplayList.__form__()
ResourceDisplayList = spyder.__types__["_Resource"](DisplayList)

DisplayList.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  DisplayList,
  "constructor_fromany",
)
DisplayList.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  DisplayList,
  "constructor_fromany",
)
DisplayList.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  DisplayList,
  "constructor_fromany",
)

class DisplayListArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "DisplayListArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, DisplayListArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(DisplayListArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DisplayListArray, target, self,deepcopy),
     name="DisplayListArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(DisplayListArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != DisplayList: self[vnr] = DisplayList(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((DisplayListArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((DisplayListArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(DisplayList,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a DisplayListArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    DisplayListArray.__dict__[DisplayListArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.DisplayList, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DisplayListArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("DisplayListArray","DisplayList","SPLIT")
spyder.core.defineconverter("DisplayList","DisplayListArray","CAST")
spyder.__types__["DisplayListArray"] = globals()["DisplayListArray"]  
arrayclass = spyder.__types__["DisplayListArray"]
spyder.__types__["ResourceDisplayListArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class DisplayListArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "DisplayListArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, DisplayListArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(DisplayListArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (DisplayListArrayArray, target, self,deepcopy),
     name="DisplayListArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(DisplayListArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != DisplayList: self[vnr] = DisplayList(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((DisplayListArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((DisplayListArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(DisplayListArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a DisplayListArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    DisplayListArrayArray.__dict__[DisplayListArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.DisplayListArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a DisplayListArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("DisplayListArrayArray","DisplayListArray","SPLIT")
spyder.core.defineconverter("DisplayListArray","DisplayListArrayArray","CAST")
spyder.__types__["DisplayListArrayArray"] = globals()["DisplayListArrayArray"]  
arrayclass = spyder.__types__["DisplayListArrayArray"]
spyder.__types__["ResourceDisplayListArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()


class MultiDisplayList(Object):
  """Spyder-generated class

 module spyder.modules.tarantula
 file 'tarantula.spy'

If objects are show()'ed in Tarantula, 
   an integer OpenGL display list is typically returned.
  This calss specifies duplicates of a displaylist, 
  each with its own AxisSystem. 
  The displaylist is rendered with for every
  instance, its axis system applied to it.
----------------------------------------------------------------------
Spyder definition:

Type MultiDisplayList {
  #!#!#!
  If objects are show()'ed in Tarantula, 
   an integer OpenGL display list is typically returned.
  This calss specifies duplicates of a displaylist, 
  each with its own AxisSystem. 
  The displaylist is rendered with for every
  instance, its axis system applied to it.
  #!#!#!
  Integer displaylist
  AxisSystemArray instances
}

----------------------------------------------------------------------
"""
  
  @staticmethod
  def typename():
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return the class name of the current object"""
    return "MultiDisplayList"
  def cast(self, othertype):
    """Auto-generated by Spyder:
     module core
     file class.py
     function generate_class
    Return an object of the type "othertype" initialized from this object"""
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)

  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""    
  def constructor_fromlist(self, *args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a MultiDisplayList object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor"""           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a MultiDisplayList object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
 
  def __init__(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""            
    MultiDisplayList.__dict__[MultiDisplayList.__constructor__](self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation"""

    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a MultiDisplayList object"
      exc += "\nNumber of arguments: value %d, keyword %d\n" % (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\n*** (MultiDisplayList) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\n*** (MultiDisplayList) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\n*** (MultiDisplayList) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\n*** (MultiDisplayList) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith("MultiDisplayList") and args[0][len("MultiDisplayList"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\n*** (MultiDisplayList) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\n*** (MultiDisplayList) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\n*** (MultiDisplayList) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self

  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  def __construct__ (self, displaylist,instances):
    """Auto-generated by Spyder:
     module core
     file construct.py
     function generate_construct
    General private constructor, for internal use only""" 
    if self.__constructor__ == self.__defaultconstructor__:
      reconstruct = spyder.core.reconstruct_std
      reconstruct_default = spyder.core.reconstruct_std  
    else:
       reconstruct = spyder.core.reconstruct
       reconstruct_default = spyder.core.reconstruct_std
    try:
      self.displaylist = reconstruct(self, Integer,"displaylist",displaylist)
    except Exception as exc:
      exc.__context__ = None; raise
    try:
      self.instances = reconstruct(self, AxisSystemArray,"instances",instances)
    except Exception as exc:
      exc.__context__ = None; raise
  def __unpack__(self,*args, **kwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""  
    try:
      return self.__unpack2__(*args, **kwargs)
    except TypeError as e:
      e.__context__ = None
      requiredmembers = ("displaylist","instances")
      missingmembers = []
      for n in range(len(args),len(requiredmembers)):
        member = requiredmembers[n]
        if member not in kwargs: missingmembers.append(member)
      raise spyder.ConstructionError("Missing arguments: %s" %  missingmembers)
    
  def __unpack2__(self,displaylist,instances,*_bogusargs, **_boguskwargs): 
    """Auto-generated by Spyder:
     module core
     file unpack.py
     function generate_unpack
    Private list/value/keyword constructor, for internal use only"""
    return displaylist,instances
  def __spydercopy__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copy
    Private copy constructor, for internal use only"""
    _missing_members = []
    try:
      displaylist = _a.displaylist
    except AttributeError:
      _missing_members.append('displaylist')
    try:
      instances = _a.instances
    except AttributeError:
      _missing_members.append('instances')
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing attributes: %s" % (type(_a).__name__, _missing_members) )
    if hasattr(_a, "__conversionstack__"): self.__conversionstack__ = _a.__conversionstack__
    return (displaylist,instances,)
  def __copydict__(self,_a):
    """Auto-generated by Spyder:
     module core
     file copy.py
     function generate_copydict
    Private dict constructor, for internal use only"""
    _missing_members = []
    try:
      displaylist = _a['displaylist']
    except KeyError:
      _missing_members.append('displaylist')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    try:
      instances = _a['instances']
    except KeyError:
      _missing_members.append('instances')
    except TypeError:
      raise spyder.ConstructionError("Object '%s' does not have keys" % type(_a).__name__)
    if len(_missing_members): raise spyder.ConstructionError("Object '%s' has missing keys: %s" % (type(_a).__name__, _missing_members) )
    return (displaylist,instances,)
  def validate(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_validate
    Validates the current object
    This is automatically called after construction
    It is NOT automatically called after editing the object"""
    try:
      pass
      self.displaylist = Integer(self.displaylist)
      self.instances = AxisSystemArray(self.instances)
      self.__validate__()
    except Exception as inst: 
      if isinstance(inst, AssertionError) or isinstance(inst, spyder.ValidationError):
        raise 
      else:
        import traceback
        e = traceback.format_exc()
        raise spyder.ValidationError(e)
  def __validate__(self):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function generate_intern_validate
    Private object validator, for internal use only"""
    pass
  @classmethod
  def _register_errors(cls):
    """Auto-generated by Spyder:
     module core
     file validate.py
     function _register_errors
    Private class method to register error messages, for internal use only"""  
    if hasattr(cls,'_update_errors'): cls._update_errors()
  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __print__(self,spaces,mode):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_print
    Pretty-prints the current object, for internal use only"""
    ret = "%s (\n" % self.typename() 
    v = self.displaylist
    if type(v) != Integer: v = Integer(v)
    ret += "%sdisplaylist = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    v = self.instances
    if type(v) != AxisSystemArray: v = AxisSystemArray(v)
    ret += "%sinstances = " % ((spaces+2) * " ") + v.__print__(spaces+2, mode) + ",\n"
    ret += "%s)" % (spaces * " ")
    return ret
  def dict(self):
    """Auto-generated by Spyder:
     module core
     file dict.py
     function generate_dict
    Converts the current object to a Python dictionary"""
    _d = {}
    v = self.displaylist
    if type(v) != Integer: v = Integer(v)
    _d["displaylist"] = v.dict()
    v = self.instances
    if type(v) != AxisSystemArray: v = AxisSystemArray(v)
    _d["instances"] = v.dict()
    return _d
  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse
    Parsing constructor, which redirects to spyder.core.parse"""
    p = spyder.core.parse(s, "Spyder", True)
    if type(p) == type(self):
      self.__dict__ = p.__dict__
      return None
    if isinstance(p, Object):
      a = self.__spydercopy__(p)
    else:
      assert isinstance(p, tuple) and len(p) == 2, type(p) #if not a Spyder object, spyder.core.parse should return a tuple 
      args, kwargs = p[0], p[1]
      if len(kwargs) > 0 and len(args) == 0:
        a = self.__copydict__(p[1])
      else:
        a = self.__unpack__(*p[0], **p[1])
    return a
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f
  def __getattr__(self, method):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_getattr
    Invokes the conversion engine """    
    m = spyder.core.method(MultiDisplayList, method, self)
    return m
  def convert(self, target,deepcopy=True):
    """Auto-generated by Spyder: 
     module core
     file convert.py
     function generate_convert
    Convert current object into type "target" """
    c = spyder.core.convert(MultiDisplayList, target, self, deepcopy)
    return c
  def threadconvert(self, target, deepcopy=True):
    """Auto-generated by Spyder:
     module core
     file convert.py
     function generate_convert
    Asynchronously convert current object into type "target"
    Immediately returns a waiting handle to the result
    Use spyder.core.thread.wait_all(<list of handles>)
     or spyder.core.thread.wait_any(<list of handles>)
     to wait for the result
    """
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (MultiDisplayList, target, self, deepcopy),
     name="MultiDisplayList=>%s" % target.typename(), 
    )
    return c
  
  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    try:
      if not isinstance(_a,MultiDisplayList) and not isinstance(self, type(_a)): return False
    except (TypeError, AttributeError, spyder.ValidationError): return False
    if _a is self: return True
    if self.displaylist != _a.displaylist: return False
    if self.instances != _a.instances: return False
    return True
  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    self = spyder.core.spyderform(cls._typetree())
spyder.__types__["MultiDisplayList"] = MultiDisplayList
spyder.core.error["MultiDisplayList"] = {}
if hasattr(MultiDisplayList, '_register_errors'): MultiDisplayList._register_errors()
MultiDisplayList._requiredmembers = [['Integer', 'displaylist', 1], ['AxisSystemArray', 'instances', 2]]
MultiDisplayList._defaultmembers = []
MultiDisplayList.__form__()
ResourceMultiDisplayList = spyder.__types__["_Resource"](MultiDisplayList)

MultiDisplayList.empty = functools.partial(spyder.__constructor, 
  "constructor_empty",
  MultiDisplayList,
  "constructor_fromany",
)
MultiDisplayList.fromlist = functools.partial(spyder.__constructor, 
  "constructor_fromlist",
  MultiDisplayList,
  "constructor_fromany",
)
MultiDisplayList.fromdict = functools.partial(spyder.__constructor, 
  "constructor_fromdict",
  MultiDisplayList,
  "constructor_fromany",
)

class MultiDisplayListArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "MultiDisplayListArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, MultiDisplayListArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(MultiDisplayListArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (MultiDisplayListArray, target, self,deepcopy),
     name="MultiDisplayListArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(MultiDisplayListArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != MultiDisplayList: self[vnr] = MultiDisplayList(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((MultiDisplayListArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((MultiDisplayListArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(MultiDisplayList,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a MultiDisplayListArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    MultiDisplayListArray.__dict__[MultiDisplayListArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.MultiDisplayList, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a MultiDisplayListArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("MultiDisplayListArray","MultiDisplayList","SPLIT")
spyder.core.defineconverter("MultiDisplayList","MultiDisplayListArray","CAST")
spyder.__types__["MultiDisplayListArray"] = globals()["MultiDisplayListArray"]  
arrayclass = spyder.__types__["MultiDisplayListArray"]
spyder.__types__["ResourceMultiDisplayListArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()
class MultiDisplayListArrayArray(spyder.core.spyderlist):
  @staticmethod
  def typename(): return "MultiDisplayListArrayArray"
  def __spydercopy__(self,a):
    list.__init__(self, a)
    if hasattr(a, "__conversionstack__"): self.__conversionstack__ = a.__conversionstack__
 
  def repr(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")
  def __repr__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_repr
    Converts the current object to a representation string
    As a side effect, saves all files within the object
    Redirects to self.__print__"""
    return self.__print__(0, "repr")

  
  @classmethod
  def _form(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Returns the spyderform of the class
     This function is automatically called at class creation"""
    return spyder.core.spyderforms[cls.typename()]
  @classmethod
  def __form__(cls):
    """Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation"""
    spyder.core.spyderform(cls._typetree()) 
    t = cls.typename()
    while t.endswith("Array"): t = t[:-len("Array")]
    spyder.core.spyderforms[cls.typename()]._members = spyder.core.spyderforms[t]._members

  def validate(self): self.__validate__()

  def __ne__(self,_a): return not self.__eq__(_a)
  def __eq__(self,_a):
    """Auto-generated by Spyder:
     module core
     file eq.py
     function generate_eq
    Comparison operator"""
    if not isinstance(_a, MultiDisplayListArrayArray) and not isinstance(self, type(_a)): return False
    if _a is self: return True
    if len(self) != len(_a): return False
    for n,nn in zip(self,_a):
      if n != nn: return False
    return True

  def __str__(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    This function is triggered by the print statement
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def str(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")
  def data(self):
    """Auto-generated by Spyder:
     module core
     file print.py
     function generate_str
    Converts the current object to a string
    Redirects to self.__print__"""
    return self.__print__(0, "str")


  @classmethod
  def _typetree(cls): 
    """Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class"""          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())

  def convert(self, target,deepcopy=True):
    c = spyder.core.convert(MultiDisplayListArrayArray, target, self, deepcopy)
    return c
  def threadconvert(self, target,deepcopy=True):
    c = spyder.core.spyderthread.threadstart (
     spyder.core.convert, (MultiDisplayListArrayArray, target, self,deepcopy),
     name="MultiDisplayListArrayArray=>%s" % target.typename(), 
    )
    return c    

  def __getattr__(self, method):    
      m = spyder.core.method(MultiDisplayListArrayArray, method, self)
      return m

  
  def list(self):
    ret = []
    for vnr in range(len(self)):
      if type(self[vnr]) != MultiDisplayList: self[vnr] = MultiDisplayList(self[vnr])
      ret.append(self[vnr].dict())
    return ret  
  
  def dict(self):
    return self.list()

  def __parse__(self, s):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    Parsing constructor, which redirects to spyder.core.parse"""
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  @classmethod
  def fromfile(c, filename, fastparse=False):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse   
    fromfile constructor"""
    n = spyder.linesep
    exc = ""
    try:
      try: #first attempt a parsing read, does not work with all data models
        s = spyder._file_load(filename).read()
        if fastparse:
          data = spyder.core.fastparse(s)
        else:
          data = spyder.core.parse(s)
        ret = c.fromdict(data[1])
      except Exception as e: 
        head = n + "### Core parser ###" + n 
        exc += head + spyder.exception()
        e.__context__ = None      
        raise
    except Exception as e: 
      try: #read using File, also works with web links
        try:
          ret = spyder.__types__["File"](filename, c).data()
        except Exception as e:
          head = n + "### Spyder.File parser ###" + n 
          exc += head + spyder.exception()
          e.__context__ = None
          raise                  
      except Exception as e:
        raise type(e)(exc)
    return ret
  def tofile(self, filename):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to file"""
    f = spyder.__types__["File"](filename, type(self), "w", self)
    f.save()
    f.close()
  def totempfile(self):
    """Auto-generated by Spyder:
     module core
     file parse.py
     function generate_parse      
    Saves object to temporary file"""
    import random, os,tempfile
    tempdir = tempfile.gettempdir()
    while 1:
      tempnam = tempdir + os.sep + str(random.randrange(1,1000000000)) +".tmp"
      if not spyder.loader.file_exists(tempnam): break
    f = spyder.__types__["File"](tempnam, type(self), "w", self)
    f.temporary(True)
    f.save()
    return f

  def __arrayvalidate__(self):
    if self.__constructor__ == self.__defaultconstructor__:
      def reconstruct(classtype, index, var):
        spyder.errorpath.append((MultiDisplayListArrayArray, classtype,index))
        ret = classtype(var)
        spyder.errorpath.pop()
        return ret
    else:
       def reconstruct(classtype, index, var):         
         classtype.__constructor__ = self.__constructor__
         spyder.errorpath.append((MultiDisplayListArrayArray, classtype, index))
         try:
           ret = classtype(var)           
         finally:
           classtype.__constructor__ = self.__defaultconstructor__
         spyder.errorpath.pop()           
         return ret               
    for v in range(len(self)):
      self[v] = reconstruct(MultiDisplayListArray,v,self[v])
  def __validate__(self):
    try:
      self.__arrayvalidate__()
    except AssertionError as exc:
      exc.__context__ = None
      raise AssertionError(spyder.exception())

  def __print__(self,spaces,mode):
    ret = "%s (\n" % self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\n"
    ret += spaces * " " +  ")"
    return ret

  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards"""
  def constructor_fromlist(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor"""    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a MultiDisplayListArrayArray object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
  
  def __init__(self,*a, **args2):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)"""
    if len(args2.keys()): raise Exception          
    MultiDisplayListArrayArray.__dict__[MultiDisplayListArrayArray.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    """Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays"""    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.MultiDisplayListArray, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], "Spyder")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a MultiDisplayListArrayArray object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    

    
spyder.core.defineconverter("MultiDisplayListArrayArray","MultiDisplayListArray","SPLIT")
spyder.core.defineconverter("MultiDisplayListArray","MultiDisplayListArrayArray","CAST")
spyder.__types__["MultiDisplayListArrayArray"] = globals()["MultiDisplayListArrayArray"]  
arrayclass = spyder.__types__["MultiDisplayListArrayArray"]
spyder.__types__["ResourceMultiDisplayListArrayArray"] = spyder.__types__["_Resource"](arrayclass)
arrayclass.empty = functools.partial(spyder.__constructor, 
"constructor_empty",
arrayclass,
"constructor_fromany",
)
arrayclass.fromlist = functools.partial(spyder.__constructor, 
"constructor_fromlist",
arrayclass,
"constructor_fromany",
)
arrayclass.fromdict = functools.partial(spyder.__constructor, 
"constructor_fromdict",
arrayclass,
"constructor_fromany",
)
arrayclass.__form__()

"""Define Object3D(Block3D) makeBlock"""
spyder.core.defineconverter("Block3D","Object3D",makeBlock)
"""Define PolygonArray(Object3D) untieObject"""
spyder.core.defineconverter("Object3D","PolygonArray",untieObject)
"""Define Polygon(PolygonArray) SPLIT"""
spyder.core.defineconverter("PolygonArray","Polygon","SPLIT")
"""Define Vector(Coordinate a) {
  return a.normalize()
}"""
def spyderconverterfunction_6(a):
  return a.normalize()

spyder.core.defineconverter("Coordinate","Vector",spyderconverterfunction_6)

del spyderconverterfunction_6
"""Define MultiInstance3D(ObjectGroup3D og) {
  if len(og.group) != 1: return None
  if og.group[0].typename() != "MultiInstance3D": return None
  ret = MultiInstance3D(og.group[0])
  for nr in range(len(ret.instances)):
    ret.instances[nr] = AxisSystem(ret.instances[nr] * og.axis)
  return ret
}"""
def spyderconverterfunction_7(og):
  if len(og.group) != 1: return None
  if og.group[0].typename() != "MultiInstance3D": return None
  ret = MultiInstance3D(og.group[0])
  for nr in range(len(ret.instances)):
    ret.instances[nr] = AxisSystem(ret.instances[nr] * og.axis)
  return ret

spyder.core.defineconverter("ObjectGroup3D","MultiInstance3D",spyderconverterfunction_7)

del spyderconverterfunction_7
