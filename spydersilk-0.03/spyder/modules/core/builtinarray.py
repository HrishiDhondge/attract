# Copyright 2007-2011, Sjoerd de Vries
# This file is part of the Spyder module: "core" 
# For licensing information, see LICENSE.txt 

arraytemplate = """class %(classname)s(spyder.core.spyderlist):  
  @staticmethod  
  def typename(): 
    return "%(classname)s"
  def cast(self, othertype):
    if type(othertype) == type(int): return othertype(self)    
    return globals()[othertype](self)
  def convert(self, target):
    c = Spyder.core.convert(%(classname)s, target, self, globals())
    return c
  def __repr__(self): return self.__print__(0, "repr")
  def repr(self): return self.__print__(0, "repr")
  def validate(self): self.__validate__()
  def __str__(self): return self.__print__(0, "str")
  def str(self): return self.__print__(0, "str")
  def data(self): return str(self)
  def __getattr__(self, method):
    m = spyder.core.method(%(classname)s, method, self)
    return m
  def list(self):
    ret = []
    for v in self:
      ret.append(v.dict())
    return ret
  def dict(self):
    return self.list()
  def __parse__(self, s):
    args = spyder.core.parse(s, "Spyder", True)
    self.__spydercopy__(args[0])
  def __arrayvalidate__(self):
    def reconstruct(classtype, index, var):
      spyder.errorpath.append((%(classname)s, classtype,index))
      try:
        ret = classtype(var)
      except (AssertionError, ConstructionError) as exc:
        exc.__context__ = None
        raise
      except Exception as exc:
        exc.__context__ = None
        raise ConstructionError(spyder.exception())
      spyder.errorpath.pop()
      return ret
    typ = spyder.__types__[\"%(prevclassname)s\"]
    for v in range(len(self)):
      self[v] = reconstruct(typ,v,self[v])  
  def __validate__(self):
    self.__arrayvalidate__()
  def __spydercopy__(self,a):
    list.__init__(self, a)
  def __print__(self,spaces,mode):
    ret = "%%s (\\n" %% self.typename()
    for v in self:
      ret += (spaces+2) * " " + v.__print__(spaces+2, mode) + ",\\n"
    ret += spaces * " " +  ")"
    return ret    
  def __init__(self, *a):
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:      
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.%(prevclassname)s, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], \"Spyder\")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass
        aa = a[0]      
        if (isinstance(aa, str) or isinstance(aa, bytes)) and aa.find(",") == -1:
          aa = aa + ","
        self.__spydercopy__(aa)
        self.validate()
      except AssertionError: raise
      except:        
        try:          
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)  
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception
          self.__parse__(a[0])
          self.validate()            
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise 
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a %(classname)s object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
  @classmethod
  def _typetree(cls): 
    \"\"\"Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class\"\"\"          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
  @classmethod
  def __form__(cls):
    \"\"\"Auto-generated by Spyder:
     module core
     file form.py
     function generate_form
     Generates the spyderform of the class
     This function is automatically called at class creation\"\"\"
    spyder.core.spyderform(cls._typetree()) 
"""

arraytemplate += _fromfilecode
arraytemplate += _tofilecode
arraytemplate += _totempfilecode

arraytemplate += """    
%(classname)s.fromlist = %(classname)s
%(classname)s.fromdict = %(classname)s
spyder.core.defineconverter("%(prevclassname)s","%(classname)s","CAST")
spyder.core.defineconverter("%(classname)s","%(prevclassname)s","SPLIT")
"""

corearraycode = """
for n in range(spyder.arraymax):
  classname = %(typename)s + (n+1) * "Array"
  prevclassname = %(typename)s + n * "Array"
  d = dict(typename=%(typename)s, classname=classname, prevclassname=prevclassname)
  defcode = spyder.core.arraytemplate %% d
  obj = compile(defcode, classname,'exec')
  import linecache
  linecache.cache[classname] = None,None,defcode.splitlines(),%(typename)s
  exec(obj)
  if classname not in globals():
    globals()[classname] = locals()[classname]
  spyder.__types__[classname] = globals()[classname]
  rclassname = \"Resource\"+classname
  globals()[rclassname] = spyder.__types__[\"_Resource\"](globals()[classname])
  globaldict[classname] = globals()[classname]
"""

def arrayfunc(typename, globaldict):
  code = corearraycode % dict(typename= '"' + typename + '"')
  obj = compile(code, typename+"-arraycode",'exec')
  import linecache
  linecache.cache[typename+"-arraycode"] = None,None,code.splitlines(),typename
  exec(obj)
  

