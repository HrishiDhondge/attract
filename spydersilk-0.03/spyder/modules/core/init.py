# Copyright 2007-2011, Sjoerd de Vries
# This file is part of the Spyder module: "core" 
# For licensing information, see LICENSE.txt 


import os, sys
oldpath = list(sys.path)
sys.path.append(os.getcwd())
from parse_members import parse_members
import spyderthread
sys.path = oldpath

ValidationError = spyder.ValidationError
ConstructionError = spyder.ConstructionError

def generate_init(typename, parentnames, source, members, deleted_members, block): 
  requiredmembers, defaultmembers, optionalmembers, args, allargs = spyder.core.parse_members(typename,members,block, spyder.safe_eval)  
  #ignore the block as it contains optional member list
  s = ""
  constructors ="""
  __constructor__ = "constructor_fromany" #Auto-generated by Spyder
  __defaultconstructor__ = __constructor__ #Auto-generated by Spyder
  def constructor_empty(self):
    \"\"\"Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards\"\"\"    
  def constructor_fromlist(self, *args, **args2):
    \"\"\"Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor\"\"\"        
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      a = self.__unpack__(*args[0])
      self.__construct__ (*a)
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e   
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a %s object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())            
    self.validate()      
  def constructor_fromdict(self, dic):
    \"\"\"Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Dict constructor\"\"\"           
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    try:
      a = self.__copydict__(dic)
      self.__construct__ (*a) 
    except AssertionError as e: 
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise         
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a %s object"      
      if isinstance(e, spyder.ConstructionError): 
        raise spyder.ConstructionError(spyder.exception(exc + "\\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())        
    self.validate()
""" % (typename, typename)
  if not len(parentnames) or len(members) > 0:
    s += constructors
  

    typenames = set()
    allmembers = list(requiredmembers)
    allmembers += defaultmembers
    for mem in allmembers:
      typenames.add(mem[0])
    constructor = "%s.__dict__[%s.__constructor__]" % (typename, typename)
  else:
    constructor = "%s.constructor_fromany" % (typename)
  s += """ 
  def __init__(self,*args, **args2):
    \"\"\"Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)\"\"\"            
    %s(self, *args, **args2)
  def constructor_fromany(self,*args, **args2):
    \"\"\"Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for the current class
    This function tries five specialized constructors in this order:
    - Copy constructor
    - Dict constructor
    - Value/Keyword constructor
    - Parsing constructor
    - List constructor
    For more information, see the Spyder documentation\"\"\"
""" % (constructor)
  if len(members) == 0:
    for parentname in parentnames:
      s+= "    %s.__init__(self,*args,**args2)\n" % parentname
    s+= "    self.validate()\n"
  else:
    s += """
    errorpath = []
    errorpath[:] = spyder.errorpath[:]
    raise_exc = None
    try:
      exc = "An error has occurred in the construction of a %(t)s object"
      exc += "\\nNumber of arguments: value %%d, keyword %%d\\n" %% (len(args), len(args2))
      try:
        construct = -1
        try:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          a = self.__spydercopy__(args[0]) #func(func(a,b,c))
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          if len(args) > 1 or len(args2) > 0: raise IndexError
          exc += "\\n*** (%(t)s) Copy constructor ***"+ spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          try:
            a = self.__copydict__(args[0]) #func({a:1,b:2,c:3})
          except Exception as e:          
            exc += "\\n*** (%(t)s) Dict constructor ***"+ spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          else:
            construct = 2
        else:
          construct = 1              
        self.__construct__ (*a)
      except AssertionError as e: 
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        raise e
      except Exception as e:
        e.__context__ = None
        spyder.errorpath[:] = errorpath[:]
        if not (len(args) > 1 or len(args2) > 0):
          if construct == 1: exc += "\\n*** (%(t)s) Copy constructor ***" + spyder.exception(newline=True)
          if construct == 2: exc += "\\n*** (%(t)s) Dict constructor ***" + spyder.exception(newline=True)
        try:
          if len(args) == 1 and len(args2) == 0 and isinstance(args[0], str):
            if args[0].startswith(\"%(t)s\") and args[0][len(\"%(t)s\"):].lstrip()[0] == "(":
              spyder.errorpath[:] = errorpath[:]  
              raise TypeError
          a = self.__unpack__(*args, **args2) #func(a,b,c)
          self.__construct__ (*a) ##
        except AssertionError as e: 
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          raise e
        except Exception as e:
          exc += "\\n*** (%(t)s) Value/Keyword constructor ***" + spyder.exception(newline=True)
          e.__context__ = None
          spyder.errorpath[:] = errorpath[:]
          if len(args) > 1 or len(args2) > 0 : raise e        
          try:
            a = self.__parse__(args[0]) #func("[a,b,c]")
            if a == None: return
            self.__construct__ (*a)
          except AssertionError as e: 
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            raise e
          except Exception as e:
            exc += "\\n*** (%(t)s) Parsing constructor ***" + spyder.exception(newline=True)
            e.__context__ = None
            spyder.errorpath[:] = errorpath[:]
            try:
              a = self.__unpack__(*args[0]) #func([a,b,c])
              self.__construct__ (*a)
            except Exception as e:              
              exc += "\\n*** (%(t)s) List constructor ***" + spyder.exception(newline=True)
              e.__context__ = None
              spyder.errorpath[:] = errorpath[:]
              raise spyder.ConstructionError
    except AssertionError as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = str(err)          
      exctyp = type(err)
    except spyder.ConstructionError as err:      
      spyder.errorpath[:] = errorpath[:]
      raise_exc = exc
      exctyp = type(err)
    except Exception as err:      
      spyder.errorpath[:] = errorpath[:]      
      raise_exc = exc+'\\n'+str(err)
      exctyp = spyder.ConstructionError
    if raise_exc: 
      raise exctyp(spyder.exception(raise_exc))
    self.validate()
    return self
""" % dict(t = typename)
  arraycode ="""
  __constructor__ = "constructor_fromany"
  __defaultconstructor__ = __constructor__
  def constructor_empty(self):
    \"\"\"Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Empty constructor, all members must be assigned manually afterwards\"\"\"
  def constructor_fromlist(self, *a):
    \"\"\"Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    List constructor\"\"\"    
    errorpath = []
    errorpath[:] = spyder.errorpath[:]    
    try:
      list.__init__(self, *a)
      self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise e
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]      
      err = str(e)
      exc = "An error has occurred in the construction of a %(classname)s object"      
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self      
  constructor_fromdict = constructor_fromlist
"""   

  arraycode += """  
  def __init__(self,*a, **args2):
    \"\"\"Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    Init function, calls the general constructor (fromany by default)\"\"\"
    if len(args2.keys()): raise Exception          
    %(classname)s.__dict__[%(classname)s.__constructor__](self, *a)  
  def constructor_fromany(self, *a):
    \"\"\"Auto-generated by Spyder:
     module core
     file init.py
     function generate_init
    General constructor for arrays\"\"\"    
    if len(a) == 0:
      spyder.core.spyderlist.__init__(self)
      return
    errorpath = []
    errorpath[:] = spyder.errorpath[:]          
    try:  
      try:
        if len(a) > 1: raise Exception
        if issubclass(Spyder.%(prevclassname)s, Spyder.StringLike):
          try:
            args = spyder.core.parse(a[0], \"Spyder\")
            if not isinstance(args, str): raise Exception
            self.__spydercopy__([args])            
            self.validate()
            return
          except:
            try:
              self.__parse__(a[0])
              self.validate()            
              return              
            except:
              pass        
        if isinstance(a[0],str) or (spyder.python3 and isinstance(a[0],bytes)): raise Exception
        spyder.errorpath[:] = errorpath[:]
        self.__spydercopy__(*a)
        self.validate()
      except AssertionError: raise
      except:        
        try:
          spyder.errorpath[:] = errorpath[:]
          self.__spydercopy__(a)
          self.validate()
        except AssertionError: raise
        except:
          spyder.errorpath[:] = errorpath[:]
          if len(a) > 1: raise Exception #
          self.__parse__(a[0])
          self.validate()
    except AssertionError as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      raise        
    except Exception as e:
      e.__context__ = None
      spyder.errorpath[:] = errorpath[:]
      err = str(e)
      exc = "An error has occurred in the construction of a %(classname)s object"
      if isinstance(e, spyder.ConstructionError):
        raise spyder.ConstructionError(spyder.exception(exc + "\\n" + err))
      else:
        raise spyder.ConstructionError(exc + spyder.exception())      
    return self    
"""
  #if len(members) == 0: return None,arraycode    
  return s,arraycode

spyder.defineunimethod("__init__", generate_init)

