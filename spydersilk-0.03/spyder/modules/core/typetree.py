# Copyright 2011, Sjoerd de Vries
# This file is part of the Spyder module: "core" 
# For licensing information, see LICENSE.txt 

_typetreedict = {}
_typetreemembers = {}

class typetreeclass(object):
  def __str__(self):
    return self.__dict__.__str__()
  def __repr__(self):
    return self.__dict__.__repr__()

import copy

def get_typetreedict(typename):
  import Spyder
  arraycount = 0
  t = typename
  is_resource = False
  if t.startswith("Resource"):
    t = t[len("Resource"):]
    is_resource = True
  while t.endswith("Array"):
    arraycount += 1
    t = t[:-len("Array")]
  t2 = t  
  if is_resource:
    get_typetreedict(t) #this will build the base typetree
    t2 = "Resource" + t
  if t in _typetreedict: 
    if arraycount == 0 and t2 in _typetreedict:
      return _typetreedict[t2]  
    tt = _typetreedict[t]
    ret = copy.copy(tt)
    ret.arraycount = arraycount
    ret.is_resource = is_resource    
    if t2 not in _typetreedict:
      _typetreedict[t2] = ret
    return ret
      
  assert not is_resource #for Resource, t must be in typetreedict by now
  
  ret = typetreeclass()
  ret.typename = t
  ret.is_resource = False
  ret.arraycount = arraycount
  ret.is_default = False 
  ret.default = None
  ret.default_expr = None
  ret.members = None
  
  build_members(t)
  if _typetreemembers[t] is None: 
    if arraycount == 0:
      _typetreedict[t] = ret  
    return ret

  ret.members = []
  members = _typetreemembers[t]
  for is_default, mtype, mname, default in members:
    mtree = copy.copy(get_typetreedict(mtype))
    mtree.is_default = is_default
    if default is not None:
     mtree.default_expr = default
     if not isinstance(default, float) \
      and not isinstance(default, int) \
      and not isinstance(default, bool):
       try:
         mtree.default_expr = eval(default, spyder.__types__.copy())
       except:
         print("Expression: %s" % default)
     if mtree.default_expr is not None:
       var = "__default_expr__" 
       dic = spyder.__types__.copy()
       dic[var] = mtree.default_expr
       exp = "%s(%s)" % (mtype, mtree.default_expr)       
       try:
         mtree.default = eval("%s(%s)" % (mtype, var), dic)
       except Exception as e:
         print("Expression: %s" % exp)
         raise
    ret.members.append((mname, mtree))
  if not len(ret.members): ret.members = None
  if t is not None: _typetreedict[t] = ret  
  return ret

def build_members(typename,cls=None):  
  if typename in _typetreemembers: return _typetreemembers[typename]
  if cls is None: 
    import Spyder
    cls = getattr(Spyder, typename)
  if not hasattr(cls, "_requiredmembers"):
    _typetreemembers[typename] = None
    return
  members =  [(False,m[0],m[1],None,m[-1]) for m in cls._requiredmembers]
  members += [(True,m[0],m[1],m[2],m[-1]) for m in cls._defaultmembers]
  members.sort(key = lambda m: m[-1])
  members = [m[:-1] for m in members]
  _typetreemembers[typename] = members

def typetree(typename, parentnames, source, members, deleted_members, block):
  s = """
  @classmethod
  def _typetree(cls): 
    \"\"\"Auto-generated by Spyder:
     module core
     file typetree.py
     function typetree
    Returns the typetree of the Spyder class\"\"\"          
    spyder.core.build_members(cls.typename(),cls)
    return spyder.core.get_typetreedict(cls.typename())
"""
  return s, s

spyder.defineunimethod("__typetree__", typetree)
